<!DOCTYPE html><html><head><meta charset="utf-8"><style>* {
    /*box-sizing: border-box;*/
}

body {
    /*width: 980px;*/
    padding-left: 10px;
    padding-right: 10px;
    margin-right: auto;
    margin-left: auto;
}

body .markdown-body {
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 3px;
    word-wrap: break-word;
}

pre {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body {
    -webkit-text-size-adjust: 100%;
    text-size-adjust: 100%;
    color: #333;
    font-family: "Segoe UI", Frutiger, "Frutiger Linotype", "Dejavu Sans", "Helvetica Neue", Arial, sans-serif;
    font-size: 20px;
    /*font: "Segoe UI";*/
    line-height: 1.6;
    word-wrap: break-word;
}

.markdown-body a {
    background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
    outline: 0;
}

.markdown-body strong {
    font-weight: bold;
    color: #BC0000;
}

.markdown-body h1 {
    margin: 0.67em 0;
}

.markdown-body img {
    border: 0;
}

.markdown-body hr {
    box-sizing: content-box;
    height: 0;
}

.markdown-body pre {
    overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
    font-family: monospace, monospace;
    font-size: 1em;
}

.markdown-body input {
    color: inherit;
    font: inherit;
    margin: 0;
}

.markdown-body html input[disabled] {
    cursor: default;
}

.markdown-body input {
    line-height: normal;
}

.markdown-body input[type="checkbox"] {
    box-sizing: border-box;
    padding: 0;
}

.markdown-body table {
    border-collapse: collapse;
    border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
    padding: 0;
}

.markdown-body input {
    font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

.markdown-body a {
    color: #4078c0;
    text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:active {
    text-decoration: underline;
}

.markdown-body hr {
    height: 0;
    margin: 15px 0;
    overflow: hidden;
    background: transparent;
    border: 0;
    border-bottom: 1px solid #ddd;
}

.markdown-body hr:before {
    display: table;
    content: "";
}

.markdown-body hr:after {
    display: table;
    clear: both;
    content: "";
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
    margin-top: 15px;
    margin-bottom: 15px;
    line-height: 1.1;
}

.markdown-body h1 {
    font-size: 30px;
}

.markdown-body h2 {
    font-size: 21px;
}

.markdown-body h3 {
    font-size: 16px;
}

.markdown-body h4 {
    font-size: 14px;
}

.markdown-body h5 {
    font-size: 12px;
}

.markdown-body h6 {
    font-size: 11px;
}

.markdown-body blockquote {
    margin: 0;
}

.markdown-body ul,
.markdown-body ol {
    padding: 0;
    margin-top: 0;
    margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
    list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
    list-style-type: lower-alpha;
}

.markdown-body dd {
    margin-left: 0;
}

.markdown-body code {
    font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 12px;
}

.markdown-body pre {
    margin-top: 0;
    margin-bottom: 0;
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body .select::-ms-expand {
    opacity: 0;
}

.markdown-body .octicon {
    font: normal normal normal 16px/1 octicons-anchor;
    display: inline-block;
    text-decoration: none;
    text-rendering: auto;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

.markdown-body .octicon-link:before {
    content: '\f05c';
}

.markdown-body:before {
    display: table;
    content: "";
}

.markdown-body:after {
    display: table;
    clear: both;
    content: "";
}

.markdown-body>*:first-child {
    margin-top: 0 !important;
}

.markdown-body>*:last-child {
    margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
    color: inherit;
    text-decoration: none;
}

.markdown-body .anchor {
    display: inline-block;
    padding-right: 2px;
    margin-left: -18px;
}

.markdown-body .anchor:focus {
    outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
    margin-top: 1em;
    margin-bottom: 16px;
    font-weight: bold;
    line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
    color: #000;
    vertical-align: middle;
    visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
    text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
    visibility: visible;
}

.markdown-body h1 {

    padding-bottom: 0.3em;
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}

.markdown-body h1 .anchor {
    line-height: 1;
}

.markdown-body h2 {

  border-top: 4px solid #4B0000;
  background-color: #BFADAD;
    padding: 5px;
    font-size: 1.75em;
    line-height: 1.225;
}

.markdown-body h2 .anchor {
    line-height: 1;
}

.markdown-body h3 {
    font-size: 1.5em;
    line-height: 1.43;
}

.markdown-body h3 .anchor {
    line-height: 1.2;
}

.markdown-body h4 {
    font-size: 1.25em;
}

.markdown-body h4 .anchor {
    line-height: 1.2;
}

.markdown-body h5 {
    font-size: 1em;
}

.markdown-body h5 .anchor {
    line-height: 1.1;
}

.markdown-body h6 {
    font-size: 1em;
    color: #777;
}

.markdown-body h6 .anchor {
    line-height: 1.1;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
    margin-top: 0;
    margin-bottom: 16px;
}

.markdown-body hr {
    height: 4px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
    padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
    margin-top: 0;
    margin-bottom: 0;
}

.markdown-body li>p {
    margin-top: 16px;
}

.markdown-body dl {
    padding: 0;
}

.markdown-body dl dt {
    padding: 0;
    margin-top: 16px;
    font-size: 1em;
    font-style: italic;
    font-weight: bold;
}

.markdown-body dl dd {
    padding: 0 16px;
    margin-bottom: 16px;
}

.markdown-body blockquote {
    padding: 0 15px;
    color: #012A58;
    border-left: 4px solid #68AFFF;
    background-color: #BAD9FB
}

.markdown-body blockquote>:first-child {
    margin-top: 0;
}

.markdown-body blockquote>:last-child {
    margin-bottom: 0;
}

.markdown-body table {
    display: block;
    width: 100%;
    overflow: auto;
    word-break: normal;
    word-break: keep-all;
}

.markdown-body table th {
    font-weight: bold;
    color: #012C45;
}

.markdown-body table th,
.markdown-body table td {
    padding: 6px 13px;
    border: 1px solid #4283A9;
}

.markdown-body table tr {
    background-color: #fff;
    border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
    background-color: #D1EEFF;
}

.markdown-body img {
    max-width: 100%;
    box-sizing: content-box;
    background-color: #fff;
}

.markdown-body code {
    padding: 0;
    padding-top: 0.2em;
    padding-bottom: 0.2em;
    margin: 0;
    font-size: 85%;
    background-color: #F1F1F1;
    /*border-radius: 3px;*/
}

.markdown-body code:before,
.markdown-body code:after {
    letter-spacing: -0.2em;
    content: "\00a0";
}

.markdown-body pre>code {
    padding: 0;
    margin: 0;
    font-size: 100%;
    word-break: normal;
    white-space: pre;
    background: transparent;
    border: 0;
}

.markdown-body .highlight {
    margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
    background-color: #FDFFCB;
    border-left: 4px solid #8E9402;
    /*border-radius: 3px;*/
}

.markdown-body .highlight pre {
    margin-bottom: 0;
    word-break: normal;
}

.markdown-body pre {
    word-wrap: normal;
}

.markdown-body pre code {
    display: inline;
    max-width: initial;
    padding: 0;
    margin: 0;
    overflow: initial;
    line-height: inherit;
    word-wrap: normal;
    background-color: transparent;
    border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
    content: normal;
}

.markdown-body kbd {
    display: inline-block;
    padding: 3px 5px;
    font-size: 11px;
    line-height: 10px;
    color: #555;
    vertical-align: middle;
    background-color: #fcfcfc;
    border: solid 1px #ccc;
    border-bottom-color: #bbb;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .pl-c {
    color: #009B00;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
    color: #0086b3;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
    color: #795da3;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
    color: #333;
}

.markdown-body .pl-ent {
    color: #63a35c;
}

.markdown-body .pl-k {
    color: #a71d5d;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
    color: #183691;
}

.markdown-body .pl-v {
    color: #ed6a43;
}

.markdown-body .pl-id {
    color: #b52a1d;
}

.markdown-body .pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.markdown-body .pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.markdown-body .pl-ml {
    color: #693a17;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.markdown-body .pl-mq {
    color: #008080;
}

.markdown-body .pl-mi {
    color: #333;
    font-style: italic;
}

.markdown-body .pl-mb {
    color: #333;
    font-weight: bold;
}

.markdown-body .pl-md {
    background-color: #ffecec;
    color: #bd2c00;
}

.markdown-body .pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.markdown-body .pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.markdown-body .pl-mo {
    color: #1d3e81;
}

.markdown-body kbd {
    display: inline-block;
    padding: 3px 5px;
    font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
    line-height: 10px;
    color: #555;
    vertical-align: middle;
    background-color: #fcfcfc;
    border: solid 1px #ccc;
    border-bottom-color: #bbb;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .plan-price-unit {
    color: #767676;
    font-weight: normal;
}

.markdown-body .task-list-item {
    list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
    margin-top: 3px;
}

.markdown-body .task-list-item input {
    margin: 0 0.35em 0.25em -1.6em;
    vertical-align: middle;
}

.markdown-body .plan-choice {
    padding: 15px;
    padding-left: 40px;
    display: block;
    border: 1px solid #e0e0e0;
    position: relative;
    font-weight: normal;
    background-color: #fafafa;
}

.markdown-body .plan-choice.open {
    background-color: #fff;
}

.markdown-body .plan-choice.open .plan-choice-seat-breakdown {
    display: block;
}

.markdown-body .plan-choice-free {
    border-radius: 3px 3px 0 0;
}

.markdown-body .plan-choice-paid {
    border-radius: 0 0 3px 3px;
    border-top: 0;
    margin-bottom: 20px;
}

.markdown-body .plan-choice-radio {
    position: absolute;
    left: 15px;
    top: 18px;
}

.markdown-body .plan-choice-exp {
    color: #999;
    font-size: 12px;
    margin-top: 5px;
}

.markdown-body .plan-choice-seat-breakdown {
    margin-top: 10px;
    display: none;
}

.markdown-body:checked+.radio-label {
    z-index: 1;
    position: relative;
    border-color: #4078c0;
}

.MathJax_Display {
    color: #4B0158;
    padding-top: 5px;
    padding-bottom: 5px;
    /*border: 2px solid #210027;*/
    background-color: #FEFAFF
}</style><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: false
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false
});
</script>
<title>section10</title></head><body><article class="markdown-body"><h1>
<a id="user-content-dynamic-memory--adts-in-c" class="anchor" href="#dynamic-memory--adts-in-c" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dynamic Memory &amp; ADTs in C</h1>

<h4>
<a id="user-content-the-heap" class="anchor" href="#the-heap" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The heap</h4>

<p>The <strong>heap</strong> is the final section in the C memory model.</p>

<p>It can be thought of a "big pile" (or "pool") of memory that is available to your program.</p>

<p>Memory is <strong>dynamically</strong> "borrowed" from the heap. We call this <strong>allocation</strong>.</p>

<p>When the borrowed memory is no longer needed, it can be "returned" and possible <strong>reused</strong>. We call this <strong>deallocation</strong>.</p>

<p>If too much memory has already been allocated, attempts to borrow additional memory fail.</p>

<p>low</p>

<table>
<thead>
<tr>
<th>stack frame</th>
</tr>
</thead>
<tbody>
<tr>
<td>code</td>
</tr>
<tr>
<td>read-only data</td>
</tr>
<tr>
<td>global data</td>
</tr>
<tr>
<td>heap $\downarrow$</td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td>stack $\uparrow$</td>
</tr>
</tbody>
</table>

<p>high</p>

<h4>
<a id="user-content-malloc" class="anchor" href="#malloc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>malloc</h4>

<p>The <code>malloc</code> (memory allocation) function obtains memory the heap dynamically. It is provided in <code>&lt;stdin.h&gt;</code>.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// malloc(s) requests s bytes of memory from the heap</span>
<span class="pl-c">//  and returns a pointer to a block of s bytes, or</span>
<span class="pl-c">//  NULL if not enough memory is available</span>
<span class="pl-c">// time: O(1)</span></pre></div>

<p>For example, if you want enough space for an array of 100 ints.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> *my_array = malloc(<span class="pl-c1">100</span> *<span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));</pre></div>

<p>or an array of n <code>struct posn</code>:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> posn *my_posn_array = malloc(n * <span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> posn));</pre></div>

<p><strong>You should always use <code>sizeof</code> with <code>malloc</code> to improve portability and to improve communication.</strong></p>

<p>Seashell will allow</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> *my_array = malloc(<span class="pl-c1">400</span>);</pre></div>

<p>instead of</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> *my_array = malloc(<span class="pl-c1">100</span> * <span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));</pre></div>

<p>but the latter is much better style and is more portable.</p>

<blockquote>
<p>Strictly speaking, the type of the <code>malloc</code> parameter is <code>size_t</code>,
which is a special type produced by the <code>sizeof</code> operator.
<code>size_t</code> and <code>int</code> are different types of integers.
Seashell is mostly forgiving, but in other C environments using
an int when C expects a <code>size_t</code> may generate a warning.
The proper <code>printf</code> placeholder to print a <code>size_t</code> is <code>%zd</code>.</p>

<p>The declaration for the malloc function is:
<code>void *malloc(size_t s);</code>
The return type is a <code>(void *)</code> (void pointer), a special pointer
that can point at any type.
<code>int *pi = malloc(sizeof(int));</code>
<code>struct posn *pp = malloc(sizeof(struct posn));</code></p>
</blockquote>

<p>An unsuccessful call of <code>malloc</code> returns <code>NULL</code>.</p>

<p>In practice it's good style to check every <code>malloc</code> return value and gracefully handle a <code>NULL</code> instead of crashing.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> *my_array = malloc(n * <span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));
<span class="pl-k">if</span> (my_array == <span class="pl-c1">NULL</span>) {
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>Sorry dude, I<span class="pl-s"><span class="pl-pds">'</span>m out of memory! I<span class="pl-pds">'</span></span>m exiting....\n<span class="pl-s"><span class="pl-pds">"</span>);</span>
<span class="pl-s">    exit(EXIT_FAILURE);</span>
<span class="pl-s">}</span></pre></div>

<p>In the "real world" you should always perform this check, but in this course, you do not have to check a <code>NULL</code> return value unless instructed otherwise.</p>

<p>The heap memory proved by <code>malloc</code> is <strong>uninitialized</strong>.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> *p = malloc(<span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));
<span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>the mystery value is: <span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, *p);</pre></div>

<p>Although <code>malloc</code> is very complicated, for the purposes of this course, you can assume that <code>malloc</code> is $O(1)$.</p>

<blockquote>
<p>There is also a <code>calloc</code> function which essentially calls <code>malloc</code> and then "initialize" the memory by filling it with zeros. <code>calloc</code> is $O(n)$, where $n$ is the size of the block.</p>
</blockquote>

<h4>
<a id="user-content-free" class="anchor" href="#free" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>free</h4>

<p>For every block of memory obtained through <code>malloc</code>, you must eventually <code>free</code> the memory (when the memory is no longer in use).</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// free(p) returns memory at a p back to the heap</span>
<span class="pl-c">// requiresL p must be from a previous malloc</span>
<span class="pl-c">// effects: the memory at p is invalid</span>
<span class="pl-c">// time: $O(1)$</span></pre></div>

<p><strong>In the Seashell environment, you must <code>free</code> every block</strong></p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> *my_array = malloc(n * <span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));
<span class="pl-c">// ...</span>
<span class="pl-c">// ...</span>
<span class="pl-en">free</span>(my_array);</pre></div>

<h4>
<a id="user-content-invalid-after-free" class="anchor" href="#invalid-after-free" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Invalid after free</h4>

<p>Once a block of memory is <code>free</code>, reading from or writing to that memory is invalid and may cause errors (or unpredictable results).</p>

<p>Similarly, it is invalid to <code>free</code> memory that was not returned by a <code>malloc</code> or that has already been <code>free</code>.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> *p = malloc(<span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));
<span class="pl-en">free</span>(p);
<span class="pl-k">int</span> k = *p; <span class="pl-c">// INVALID</span>
*p = <span class="pl-c1">42</span>; <span class="pl-c">// INVALID</span>
<span class="pl-en">free</span>(p); <span class="pl-c">// INVALID</span>
p = <span class="pl-c1">NULL</span>; <span class="pl-c">// GOOD STYLE</span></pre></div>

<p>Pointer variables may still contain the address of the memory that was freed, so it is often good style to assign <code>NULL</code> to a freed pointer variable.</p>

<h4>
<a id="user-content-memory-leaks" class="anchor" href="#memory-leaks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Memory leaks</h4>

<p>A memory leak occurs when allocated memory is not eventually freed.</p>

<p>Programs that leak memory may suffer degraded performance or eventually crash.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> *ptr;
ptr = malloc(<span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));
ptr = malloc(<span class="pl-k">sizeof</span>(<span class="pl-k">int</span>)); <span class="pl-c">// memory leak!</span></pre></div>

<p>In this example, the address from the original <code>malloc</code> has been overwritten.</p>

<p>That memory is now "lost" (or leaked) and so it can never by freed.</p>

<h4>
<a id="user-content-garbage-collection" class="anchor" href="#garbage-collection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Garbage collection</h4>

<p>Many modern languages (including Racket) have a <strong>garbage collector</strong>.</p>

<p>A garbage collector <strong>detects</strong> when memory is no longer in use and <strong>automatically</strong> frees memory and returns it to the heap.</p>

<p>One disadvantage of a garbage collector is that it can be slow and affect performance, which is a concern in high performance computing.</p>

<h4>
<a id="user-content-merge-sort" class="anchor" href="#merge-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Merge sort</h4>

<p>In section 09 we saw a Racket implementation of the divide and conquer algorithm <strong>merge sort</strong> that is $O(n\logn)$.</p>

<p>In merge sort, the data is split into two smaller groups. After each smaller group is sorted, they are merged together.</p>

<p>To simplify our C implementation, we will use a <code>merge</code> helper function.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// merge(dest, src1, len1, src2, len2) modifies dest to contain</span>
<span class="pl-c">//  the elements from both src1 and src2 in sorted order</span>
<span class="pl-c">// requires: length of dest is at least (len1 + len2)</span>
<span class="pl-c">//           src1 and src2 are sorted</span>
<span class="pl-c">// effects: modifies dest</span>
<span class="pl-c">// time: O(n), where n is len1 + len2</span>

<span class="pl-k">void</span> <span class="pl-en">merge</span>(<span class="pl-k">int</span> dest[], <span class="pl-k">const</span> <span class="pl-k">int</span> src1[], <span class="pl-k">int</span> len1, <span class="pl-k">const</span> <span class="pl-k">int</span> src2[], <span class="pl-k">int</span> len2) {
    <span class="pl-k">int</span> pos1 = <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> pos2 = <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; len1 + len2; ++i) {
        <span class="pl-k">if</span> (pos1 == len1 || (pos2 &lt; len2 &amp;&amp; src2[pos2] &lt; src1[pos1])) {
            dest[i] = src2[pos2];
            ++pos2;
        } <span class="pl-k">else</span> {
            dest[i] = src1[pos1];
            ++pos1;
        }
    }
}

<span class="pl-k">void</span> <span class="pl-en">merge_sort</span>(<span class="pl-k">int</span> a[], <span class="pl-k">int</span> len) {
    <span class="pl-k">if</span> (len &lt;= <span class="pl-c1">1</span>) <span class="pl-k">return</span>;
    <span class="pl-k">int</span> llen = len / <span class="pl-c1">2</span>;
    <span class="pl-k">int</span> rlen = len - llen;

    <span class="pl-k">int</span> *left = <span class="pl-c1">malloc</span>(llen * <span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));
    <span class="pl-k">int</span> *right = <span class="pl-c1">malloc</span>(rlen * <span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));

    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; llen; ++i) left[i] = a[i];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; rlen; ++i) right[i] = a[i + llen];

    <span class="pl-c1">merge_sort</span>(left, llen);
    <span class="pl-c1">merge_sort</span>(right, rlen);

    <span class="pl-c1">merge</span>(a, left, llen, right, rlen);

    <span class="pl-c1">free</span>(left);
    <span class="pl-c1">free</span>(right);
}</pre></div>

<h4>
<a id="user-content-duration" class="anchor" href="#duration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Duration</h4>

<p>Using dynamic (heap) memory, a function can obtain memory that <strong>persists</strong> after the function has returned.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// build_array(n) returns a new array initialized with</span>
<span class="pl-c">// values a[0] = 0, a[1] = 1, ... a[n-1] = n-1</span>
<span class="pl-c">// effects: allocates a heap array (caller must free)</span>
<span class="pl-k">int</span> *<span class="pl-en">build_array</span>(<span class="pl-k">int</span> len) {
    <span class="pl-c1">assert</span>(len &gt; <span class="pl-c1">0</span>);
    <span class="pl-k">int</span> *a = <span class="pl-c1">malloc</span>(len * <span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i=<span class="pl-c1">0</span>; i &lt; len; ++i) {
        a[i] = i;
    }
    <span class="pl-k">return</span> a; <span class="pl-c">// array exists beyond function return</span>
}</pre></div>

<p>The caller (client) is responsible for freeing the memory (the contract should communicate this).</p>

<p>The <code>&lt;string.h&gt;</code> function <code>strdup</code> makes a duplicate of a string.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// my_strdup(s) makes a duplicate of s</span>
<span class="pl-c">// effects: allocates memory (caller must free)</span>
<span class="pl-k">char</span> *<span class="pl-en">my_strdup</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *s) {
    <span class="pl-k">char</span> *newstr = <span class="pl-c1">malloc</span>((<span class="pl-c1">strlen</span>(s) + <span class="pl-c1">1</span>) * <span class="pl-k">sizeof</span>(<span class="pl-k">char</span>));
    <span class="pl-c1">strcpy</span>(newstr, s);
    <span class="pl-k">return</span> newstr;
}</pre></div>

<p>Recall that the <code>strcpy(dest, src)</code> copies the characters from <code>src</code> to <code>dest</code>, and the <code>dest</code> array must be large enough.</p>

<p>When allocating memory for strings, don't forget to the include space for the null terminator.</p>

<h4>
<a id="user-content-resizing-arrays" class="anchor" href="#resizing-arrays" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Resizing arrays</h4>

<p>Because <code>malloc</code> requires the size of the block of memory to be allocated, it does not seem to solve the problem:</p>

<p>"What if we do not know the length of an array in advance?"</p>

<p>To solve this problem, we can <strong>resize</strong> an array by:</p>

<ul>
<li>  creating a new array</li>
<li>  copying the items from the old to the new array</li>
<li>  free the old array</li>
</ul>

<h4>
<a id="user-content-realloc" class="anchor" href="#realloc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>realloc</h4>

<p>To make resizing arrays easier, there is a <code>realloc</code> function.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// realloc(p, newsize) resizes the memory block at p</span>
<span class="pl-c">//  to be newsize and returns a pointer to the</span>
<span class="pl-c">//  new location, or NULL if unsuccessful</span>
<span class="pl-c">// requires: p must be from a previous malloc/realloc</span>
<span class="pl-c">// effects: the memory at p is invalid (freed)</span>
<span class="pl-c">// time: O(n), where n is newsize</span></pre></div>

<p>Similar to our previous example, <code>realloc</code> preserves the contents from the old array location.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> *my_array = malloc(<span class="pl-c1">100</span> * <span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));
<span class="pl-c">// stuff happens</span>
my_array = realloc(my_array, <span class="pl-c1">101</span> * <span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));</pre></div>

<p>The pointer returned by <code>realloc</code> may actually be the original pointer, depending on the circumstances.</p>

<p>Regardless, after <code>realloc</code> <strong>only the new returned pointer can be used</strong>. You should assume that the parameter of <code>realloc</code> was freed and is not invalid.</p>

<p>Typically, <code>realloc</code> is used to request a larger size and the additional memory is uninitialized.</p>

<p>If the size is smaller, the extraneous memory is discarded.</p>

<blockquote>
<p><code>realloc(NULL, s)</code> behaves the same as <code>malloc(s)</code>.
<code>realloc(ptr, 0)</code> behaves the same as <code>free(ptr)</code>.</p>
</blockquote>

<h4>
<a id="user-content-string-io-strings-of-unknown-size" class="anchor" href="#string-io-strings-of-unknown-size" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>String I/O: strings of unknown size</h4>

<p>In section 08 we saw how reading in strings can be susceptible to buffer overruns.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> str[<span class="pl-c1">81</span>];
<span class="pl-k">int</span> retval = scanf(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%s</span><span class="pl-pds">"</span></span>, str);</pre></div>

<p>The target array is often oversized to ensure there is capacity to store the string. Unfortunately, regardless of the length of the array, a buffer overrun may occur.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// readstr() reads in a new string from I/O or return NULL if EOF</span>
<span class="pl-c">// effects: allocates memory (caller must free)</span>

<span class="pl-k">char</span> *<span class="pl-en">readstr</span>(<span class="pl-k">void</span>) {
    <span class="pl-k">char</span> c;
    <span class="pl-k">if</span> (<span class="pl-c1">scanf</span>(<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-c1">%s</span><span class="pl-pds">"</span></span>, &amp;c) != <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
    <span class="pl-k">char</span> *str = <span class="pl-c1">malloc</span>(<span class="pl-c1">1</span> * <span class="pl-k">sizeof</span>(<span class="pl-k">char</span>));
    <span class="pl-k">int</span> len = <span class="pl-c1">0</span>;
    <span class="pl-k">do</span> {
        str[len] = c;
        ++len;
        str = <span class="pl-c1">realloc</span>(str, (len + <span class="pl-c1">1</span>) * <span class="pl-k">sizeof</span>(<span class="pl-k">char</span>));
        <span class="pl-k">if</span> (<span class="pl-c1">scanf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%s</span><span class="pl-pds">"</span></span>, &amp;c) != <span class="pl-c1">1</span>) <span class="pl-k">break</span>;
    } <span class="pl-k">while</span> (c != <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span> &amp;&amp; c != <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>);
    str[len] = <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>;
    <span class="pl-k">return</span> str;
}</pre></div>

<h4>
<a id="user-content-amortized-analysis" class="anchor" href="#amortized-analysis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Amortized analysis</h4>

<p>Unfortunately, the running time of <code>readstr</code> is $O(n^2)$, where $n$ is the length of the string.</p>

<p>This is because <code>realloc</code> is $O(n)$ and occurs inside of the loop;</p>

<p>A better approach might be to allocate <strong>more memory than necessary</strong> and only call <code>realloc</code> when the array is "full".</p>

<p>A popular strategy is to <strong>double</strong> the size of the array when it is full.</p>

<p>Similar to working with maximum-length arrays, we need to keep track of the actual length in addition to allocated length.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> *<span class="pl-en">readstr</span>(<span class="pl-k">void</span>) {
    <span class="pl-k">char</span> c;
    <span class="pl-k">if</span> (<span class="pl-c1">scanf</span>(<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-c1">%s</span><span class="pl-pds">"</span></span>, &amp;c) != <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
    <span class="pl-k">int</span> maxlen = <span class="pl-c1">1</span>;
    <span class="pl-k">char</span> *str = <span class="pl-c1">malloc</span>(maxlen * <span class="pl-k">sizeof</span>(<span class="pl-k">char</span>));
    <span class="pl-k">int</span> len = <span class="pl-c1">0</span>;
    <span class="pl-k">do</span> {
        str[len] = c;
        ++len;
        <span class="pl-k">if</span> (len == maxlen) {
            maxlen *= <span class="pl-c1">2</span>;
            str = <span class="pl-c1">realloc</span>(str, maxlen * <span class="pl-k">sizeof</span>(<span class="pl-k">char</span>));
        }
        <span class="pl-k">if</span> (<span class="pl-c1">scanf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%c</span><span class="pl-pds">"</span></span>, &amp;c) != <span class="pl-c1">1</span>) <span class="pl-k">break</span>;
    } <span class="pl-k">while</span> (c != <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span> &amp;&amp; c != <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>);
    str[len] = <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>;
    str = <span class="pl-c1">realloc</span>(str, (len + <span class="pl-c1">1</span>) * <span class="pl-k">sizeof</span>(<span class="pl-k">char</span>));
    <span class="pl-k">return</span> str;
}</pre></div>

<p>With our "doubling" strategy, most iterations will be $O(1)$, unless it is necessary to resize (<code>realloc</code>) the array.</p>

<p>the resizing time for the first 32 iterations would be:</p>

<p>2,4,0,8,0,0,0,16,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64</p>

<p>For $n$ iterations, the total resizing time is at most:</p>

<p>$$2n+n+\frac{n}{2}+\frac{n}{4}+\cdots + 2 = 4n-2 = O(n)$$</p>

<p>By using this doubling strategy, the total run time for <code>readstr</code> is now only $O(n)$.</p>

<p>In other words, the <strong>amortized</strong> ("average") time for each iteration is: $O(n)/n = O(1)$.</p>

<h4>
<a id="user-content-adts-in-c" class="anchor" href="#adts-in-c" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ADTs in C</h4>

<p>With dynamic memory, we now have the ability to implement an <em>Abstract Data Type (ADT)</em> in C.</p>

<p>In section 02, the first ADT we say was a simple account ADT, which stored a username and a password. It demonstrated <strong>information hiding</strong>, which provides both <em>security</em> and <em>flexibility</em>.</p>

<p>We will also need to use <strong>opaque</strong> structures (incomplete declarations without fields).</p>

<p>In the <strong>interface</strong>, we only provide an <em>incomplete declaration</em>. In addition to the normal operations, we provide functions to <strong>create</strong> and <strong>destroy</strong> instances of the ADT.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// account.h -- a simple account ADT module</span>

<span class="pl-k">struct</span> account; <span class="pl-c">// incomplete</span>

<span class="pl-c">// create_account(username, password) creates an account </span>
<span class="pl-c">// with the given username and password </span>
<span class="pl-c">// effects: allocates memory (client must call destroy_account) </span>
<span class="pl-k">struct</span> account *<span class="pl-en">create_account</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *username, <span class="pl-k">const</span> <span class="pl-k">char</span> *password); 

<span class="pl-c">// destroy_account(acc) removes all memory for acc </span>
<span class="pl-c">// effects: memory at acc is free'd and invalid</span>
<span class="pl-k">void</span> <span class="pl-en">destroy_account</span>(<span class="pl-k">struct</span> account *acc);</pre></div>

<p>Because the interface only provides an incomplete declaration, the <strong>client</strong> does not know the fields of the <code>account</code> structure.</p>

<p>The client can only define a pointer to the structure, which is returned by <code>create_account</code>.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// client.c</span>

<span class="pl-k">char</span> username[<span class="pl-c1">9</span>]; <span class="pl-k">char</span> password[<span class="pl-c1">41</span>];

<span class="pl-c">// ...</span>

<span class="pl-k">struct</span> account *my_account = create_account(username, password);

<span class="pl-c">// ...</span>

<span class="pl-en">destroy_account</span>(my_account);</pre></div>

<p>The compete structure declaration only appears in the <strong>implementation</strong>.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// account.c</span>
<span class="pl-k">struct</span> account {
    <span class="pl-k">char</span> *uname;
    <span class="pl-k">char</span> *pword; 
};</pre></div>

<p><code>create_account</code> returns a pointer to a <strong>new</strong> account.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> account *<span class="pl-en">create_account</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *username, <span class="pl-k">const</span> <span class="pl-k">char</span> *password) {
    <span class="pl-k">struct</span> account *a = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> account));
    a-&gt;uname = <span class="pl-c1">malloc</span>((<span class="pl-c1">strlen</span>(username) + <span class="pl-c1">1</span>) * <span class="pl-k">sizeof</span>(<span class="pl-k">char</span>)); <span class="pl-c1">strcpy</span>(a-&gt;uname, username);
    a-&gt;pword = <span class="pl-c1">malloc</span>((<span class="pl-c1">strlen</span>(password) + <span class="pl-c1">1</span>) * <span class="pl-k">sizeof</span>(<span class="pl-k">char</span>)); <span class="pl-c1">strcpy</span>(a-&gt;pword, password);
    <span class="pl-k">return</span> a;
}</pre></div>

<p>It makes <strong>duplicates</strong> of the username and password strings provided by the client.</p>

<p>In C, our ADT also requires a <code>destroy_account</code> to <code>free</code> the memory created (both the fields and the structure itself).</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">destroy_account</span>(<span class="pl-k">struct</span> account *a) {
    <span class="pl-c1">free</span>(a-&gt;username); 
    <span class="pl-c1">free</span>(a-&gt;password); 
    <span class="pl-c1">free</span>(a);
}</pre></div>

<p>The remaining operations are straightforward.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">const</span> <span class="pl-k">char</span> *<span class="pl-en">get_username</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> account *acc) {
    <span class="pl-k">return</span> acc-&gt;uname;
}

<span class="pl-k">bool</span> <span class="pl-en">is_correct_password</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> account *acc, <span class="pl-k">const</span> <span class="pl-k">char</span> *word) {
    <span class="pl-k">return</span> (<span class="pl-c1">strcmp</span>(acc-&gt;pword, word) == <span class="pl-c1">0</span>);
}</pre></div>

<h4>
<a id="user-content-implementing-a-stack-adt" class="anchor" href="#implementing-a-stack-adt" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implementing a Stack ADT</h4>

<p>The <strong>Stack ADT</strong> (one of the Collection ADTs) is more representative.</p>

<p>The interface is nearly identical to the stack implementation from section 08 that demonstrated maximum-length arrays.</p>

<p>The only differences are: it uses an opaque structure, it provides <code>create</code> and <code>destroy</code> functions, and there is no maximum: it can store any arbitrary number of integers.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// stack.h (INTERFACE)</span>

<span class="pl-k">struct</span> stack;

<span class="pl-k">struct</span> stack *<span class="pl-en">create_stack</span>(<span class="pl-k">void</span>);

<span class="pl-k">bool</span> <span class="pl-en">stack_is_empty</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> stack *s);

<span class="pl-k">int</span> <span class="pl-en">stack_top</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> stack *s);

<span class="pl-k">int</span> <span class="pl-en">stack_pop</span>(<span class="pl-k">struct</span> stack *s);

<span class="pl-k">void</span> <span class="pl-en">stack_push</span>(<span class="pl-k">int</span> item, <span class="pl-k">struct</span> stack *s);

<span class="pl-k">void</span> <span class="pl-en">stack_destroy</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> stack *s);</pre></div>

<p>The Stack ADT uses the "doubling" strategy. It is typical to have an initial size that is not too wasteful, but avoids excessive doubling for small stacks.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// stack.c (IMPLEMENTATION)</span>

<span class="pl-k">struct</span> stack {
    <span class="pl-k">int</span> len;
    <span class="pl-k">int</span> maxlen;
    <span class="pl-k">int</span> *data;
};

<span class="pl-k">static</span> <span class="pl-k">const</span> <span class="pl-k">int</span> initial_size = <span class="pl-c1">32</span>;

<span class="pl-k">struct</span> stack *<span class="pl-en">create_stack</span>(<span class="pl-k">void</span>) {
    <span class="pl-k">struct</span> stack *s = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> stack));
    s-&gt;len = <span class="pl-c1">0</span>;
    s-&gt;maxlen = initial_size;
    s-&gt;data = <span class="pl-c1">malloc</span>(s-&gt;maxlen * <span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));
    <span class="pl-k">return</span> s;
}</pre></div>

<p>The doubling is implemented in <code>push</code>.</p>

<p><code>destroy</code> must <code>free</code> the field and the structure itself.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// Time: O(1) [amortized]</span>

<span class="pl-k">void</span> <span class="pl-en">stack_push</span>(<span class="pl-k">int</span> item, <span class="pl-k">struct</span> stack *s) {
    <span class="pl-c1">assert</span>(s);
    <span class="pl-k">if</span> (s-&gt;len == s-&gt;maxlen) {
        s-&gt;maxlen *= <span class="pl-c1">2</span>;
        s-&gt;data = <span class="pl-c1">realloc</span>(s-&gt;data, s-&gt;maxlen * <span class="pl-k">sizeof</span>(<span class="pl-k">int</span>));
    }
    s-&gt;data[s-&gt;len] = item;
    s-&gt;len += <span class="pl-c1">1</span>;
}

<span class="pl-k">void</span> <span class="pl-en">stack_destroy</span>(<span class="pl-k">struct</span> stack *s) {
    <span class="pl-c1">free</span>(s-&gt;data);
    <span class="pl-c1">free</span>(s);
}</pre></div>

<p>The remaining operations are identical to the maximum-length implementation.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">bool</span> <span class="pl-en">stack_is_empty</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> stack *s) {
    <span class="pl-c1">assert</span>(s);
    <span class="pl-k">return</span> s-&gt;len == <span class="pl-c1">0</span>;
}

<span class="pl-k">int</span> <span class="pl-en">stack_top</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> stack *s) {
    <span class="pl-c1">assert</span>(s);
    <span class="pl-c1">assert</span>(s-&gt;len);
    <span class="pl-k">return</span> s-&gt;data[s-&gt;len - <span class="pl-c1">1</span>];
}

<span class="pl-k">int</span> <span class="pl-en">stack_pop</span>(<span class="pl-k">struct</span> stack *s) {
    <span class="pl-c1">assert</span>(s);
    <span class="pl-c1">assert</span>(s-&gt;len);
    s-&gt;len -= <span class="pl-c1">1</span>;
    <span class="pl-k">return</span> s-&gt;data[s-&gt;len];
}</pre></div>

<h4>
<a id="user-content-goals-of-this-section" class="anchor" href="#goals-of-this-section" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Goals of this section</h4>

<ul>
<li>  describe the heap</li>
<li>  use the functions <code>malloc</code>, <code>realloc</code> and <code>free</code> to interact with
the heap</li>
<li>  explain that the heap is finite, and demonstrate how to use
check <code>malloc</code> for success</li>
<li>  describe memory leaks, how they occur, and how to prevent
them</li>
<li>  describe the doubling strategy, and how it can be used to
manage dynamic arrays to achieve an amortized $O(1)$ run-time
for additions</li>
<li>  create dynamic <code>resizable</code> arrays in the heap</li>
<li>  write functions that create and return a new <code>struct</code>
</li>
<li>  document dynamic memory side-effects in contracts</li>
</ul>
</article></body></html>