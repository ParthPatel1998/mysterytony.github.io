<!DOCTYPE html><html><head><meta charset="utf-8"><style>@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff');
}

* {
    box-sizing: border-box;
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
}

body .markdown-body {
    padding: 45px;
    border: 1px solid #ddd;
    border-radius: 3px;
    word-wrap: break-word;
}

pre {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body {
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  color: #333;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body strong {
  font-weight: bold;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body input {
  font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

.markdown-body a {
  color: #4078c0;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before {
  display: table;
  content: "";
}

.markdown-body hr:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body .select::-ms-expand {
  opacity: 0;
}

.markdown-body .octicon {
  font: normal normal normal 16px/1 octicons-anchor;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.markdown-body .octicon-link:before {
  content: '\f05c';
}

.markdown-body:before {
  display: table;
  content: "";
}

.markdown-body:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .anchor {
  display: inline-block;
  padding-right: 2px;
  margin-left: -18px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #000;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h1 .anchor {
  line-height: 1;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 .anchor {
  line-height: 1;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h3 .anchor {
  line-height: 1.2;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h4 .anchor {
  line-height: 1.2;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h5 .anchor {
  line-height: 1.1;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body h6 .anchor {
  line-height: 1.1;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

.markdown-body code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .pl-c {
  color: #969896;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #0086b3;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #795da3;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #333;
}

.markdown-body .pl-ent {
  color: #63a35c;
}

.markdown-body .pl-k {
  color: #a71d5d;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #183691;
}

.markdown-body .pl-v {
  color: #ed6a43;
}

.markdown-body .pl-id {
  color: #b52a1d;
}

.markdown-body .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

.markdown-body .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

.markdown-body .pl-ml {
  color: #693a17;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

.markdown-body .pl-mq {
  color: #008080;
}

.markdown-body .pl-mi {
  color: #333;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #333;
  font-weight: bold;
}

.markdown-body .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

.markdown-body .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

.markdown-body .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

.markdown-body .pl-mo {
  color: #1d3e81;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .plan-price-unit {
  color: #767676;
  font-weight: normal;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

.markdown-body .plan-choice {
  padding: 15px;
  padding-left: 40px;
  display: block;
  border: 1px solid #e0e0e0;
  position: relative;
  font-weight: normal;
  background-color: #fafafa;
}

.markdown-body .plan-choice.open {
  background-color: #fff;
}

.markdown-body .plan-choice.open .plan-choice-seat-breakdown {
  display: block;
}

.markdown-body .plan-choice-free {
  border-radius: 3px 3px 0 0;
}

.markdown-body .plan-choice-paid {
  border-radius: 0 0 3px 3px;
  border-top: 0;
  margin-bottom: 20px;
}

.markdown-body .plan-choice-radio {
  position: absolute;
  left: 15px;
  top: 18px;
}

.markdown-body .plan-choice-exp {
  color: #999;
  font-size: 12px;
  margin-top: 5px;
}

.markdown-body .plan-choice-seat-breakdown {
  margin-top: 10px;
  display: none;
}

.markdown-body :checked+.radio-label {
  z-index: 1;
  position: relative;
  border-color: #4078c0;
}
</style><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: false
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false
});
</script>
<title>section8</title></head><body><article class="markdown-body"><h1>
<a id="user-content-section-8-arrays--strings" class="anchor" href="#section-8-arrays--strings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Section 8: Arrays &amp; Strings</h1>

<h4>
<a id="user-content-arrays" class="anchor" href="#arrays" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Arrays</h4>

<p>C only has two built-in types of "compound" data storage:</p>

<ul>
<li>  structures</li>
<li>  arrays</li>
</ul>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> my_array[<span class="pl-c1">6</span>] = {<span class="pl-c1">4</span>,<span class="pl-c1">8</span>,<span class="pl-c1">15</span>,<span class="pl-c1">16</span>,<span class="pl-c1">23</span>,<span class="pl-c1">42</span>};</pre></div>

<p>An arrays is a data structure that contains a <strong>fixed number</strong> of elements that all have the <strong>same type</strong>.</p>

<p><strong>Because arrays are built-in to C, they are used for many tasks where lists are used in Racket, but arrays and lists are very different.</strong></p>

<p>To define an array we must know the <strong>length</strong> of the array <strong>in advance</strong>.</p>

<p>Each individual value in the array is known as an <strong>element</strong>. To access an element, its <strong>index</strong> is required.</p>

<p>The first element of <code>my_array</code> is at index <code>0</code>, and it is written as <code>my_array[0]</code>.</p>

<p>The second element is <code>my_array[1]</code> and the last is <code>my_array[5]</code>.</p>

<p><strong>In computer science we often start counting at 0.</strong></p>

<h4>
<a id="user-content-array-initialization" class="anchor" href="#array-initialization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Array Initialization</h4>

<p>Arrays can only be initialized with braces (<code>{}</code>).</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> a[<span class="pl-c1">6</span>] = {<span class="pl-c1">4</span>, <span class="pl-c1">8</span>, <span class="pl-c1">15</span>, <span class="pl-c1">16</span>, <span class="pl-c1">23</span>, <span class="pl-c1">42</span>};

a = {<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>}; <span class="pl-c">// INVALID </span>
a = ??? ; <span class="pl-c">// INVALID</span></pre></div>

<p>Once defined, the entire array cannot be assigned to at once.</p>

<p>Each individual element must be mutated.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">for</span> (<span class="pl-k">int</span> i=<span class="pl-c1">0</span>; i &lt; <span class="pl-c1">6</span>; ++i) {
    a[i] = <span class="pl-c1">0</span>; 
}</pre></div>

<p>Like variables, the value of an uninitialized array depends on the scope of the array: </p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> a[<span class="pl-c1">5</span>];</pre></div>

<ul>
<li>  uninitialized global arrays are zero-filled. </li>
<li>   uninitialized local arrays are filled with arbitrary (“garbage”) values from the stack.</li>
</ul>

<p>If there are not enough elements in the braces, the remaining values are initialized to zero (even with local arrays).</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> b[<span class="pl-c1">5</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>}; <span class="pl-c">// b[3] &amp; b[4] = 0 </span>
<span class="pl-k">int</span> c[<span class="pl-c1">5</span>] = {<span class="pl-c1">0</span>}; <span class="pl-c">// c[0]...c[4] = 0</span></pre></div>

<p>If an array is initialized, the length of the array can be omitted from the declaration and automatically determined from the number of elements in the initialization.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> a[] = {<span class="pl-c1">4</span>, <span class="pl-c1">8</span>, <span class="pl-c1">15</span>, <span class="pl-c1">16</span>, <span class="pl-c1">23</span>, <span class="pl-c1">42</span>}; <span class="pl-c">// int a[6] = ...</span></pre></div>

<p>This syntax is only allowed if the array is initialized.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> b[]; <span class="pl-c">// INVALID</span></pre></div>

<h4>
<a id="user-content-array-size" class="anchor" href="#array-size" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Array size</h4>

<p>The <strong>length</strong> of an array is the number of elements in the array.</p>

<p>The <strong>size</strong> of an array is the number of bytes it occupies in memory.</p>

<p>An array of $k$ elements, each of size $s$, requires exactly $k\times s$ bytes.</p>

<p>In the C memory array elements are adjacent to each other. Each element of an array is placed in memory immediately after the previous element.</p>

<p>If <code>a</code> is an integer array with six elements (<code>int a[6]</code>) the size of <code>a</code> is: $6\times 4 = 24$.</p>

<h4>
<a id="user-content-array-length" class="anchor" href="#array-length" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Array length</h4>

<p>C does not explicitly keep track of the array <strong>length</strong> as part of the array data structure.</p>

<p><strong>You must keep track of the array length separately.</strong></p>

<p>Typically, the array length is stored in a separate variable.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">const</span> <span class="pl-k">int</span> a_length = <span class="pl-c1">6</span>; 
<span class="pl-k">int</span> a[a_length] = {<span class="pl-c1">4</span>, <span class="pl-c1">8</span>, <span class="pl-c1">15</span>, <span class="pl-c1">16</span>, <span class="pl-c1">23</span>, <span class="pl-c1">42</span>};</pre></div>

<h4>
<a id="user-content-the-array-identifier" class="anchor" href="#the-array-identifier" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The array identifier</h4>

<p>The <strong>value</strong> of an array (<code>a</code>) is the same as the <strong>address</strong> of the array (<code>&amp;a</code>), which is also the address of the first element (<code>&amp;a[0]</code>).</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> a[] = {<span class="pl-c1">4</span>, <span class="pl-c1">8</span>, <span class="pl-c1">15</span>, <span class="pl-c1">16</span>, <span class="pl-c1">23</span>, <span class="pl-c1">42</span>};
<span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%p</span> <span class="pl-c1">%p</span> <span class="pl-c1">%p</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, a, &amp;a, &amp;a[<span class="pl-c1">0</span>]);
<span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%d</span> <span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, a[<span class="pl-c1">0</span>], *a);

0x5000 0x5000 0x5000 
<span class="pl-c1">4</span> <span class="pl-c1">4</span></pre></div>

<p>Dereferencing the array (<code>*a</code>) is equivalent to referencing the first element (<code>a[0]</code>).</p>

<h4>
<a id="user-content-passing-arrays-to-functions" class="anchor" href="#passing-arrays-to-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Passing arrays to functions</h4>

<p>When an array is passed to a function only the <strong>address</strong> of the array is copied into the stack frame. This is more efficient than copying the entire array to the stack.</p>

<p>Typically, the length of the array is unknown, and is provided as a separate parameter.</p>

<p>As we have seen before, passing an address to a function allows the function to change (mutate) the contents at that address.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">array_add1</span>(<span class="pl-k">int</span> a[], <span class="pl-k">int</span> len) {
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; len; ++i) { 
        ++a[i];
    }
}</pre></div>

<p>It's good style to use the <code>const</code> keyword to prevent mutation and communicate that no mutation occurs.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">sum_array</span>(<span class="pl-k">const</span> <span class="pl-k">int</span> a[], <span class="pl-k">int</span> len) {
    <span class="pl-k">int</span> sum = <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; len; ++i) {
        sum += a[i];
    }
    <span class="pl-k">return</span> sum;
}</pre></div>

<h4>
<a id="user-content-pointer-arithmetic" class="anchor" href="#pointer-arithmetic" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pointer arithmetic</h4>

<p>We have not yet discussed any <strong>pointer arithmetic</strong>.</p>

<p>C allows an integer to be added to a pointer, but the result may not be what you expect.</p>

<p>If <code>p</code> is a pointer, the value of (<code>p+1</code>) <strong>depends on the type</strong> of the pointer <code>p</code>.</p>

<p><code>(p+1)</code> adds the <code>sizeof</code> whatever <code>p</code> points at.</p>

<h4>
<a id="user-content-pointer-arithmetic-rules" class="anchor" href="#pointer-arithmetic-rules" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pointer arithmetic rules</h4>

<ul>
<li>  When adding an integer <code>i</code> to a pointer <code>p</code>, the address computed by <code>(p+i)</code> in C is given in "normal" arithmetic by:
$$p+i\times sizeof(*p)$$</li>
<li>  Subtracting an integer from a pointer <code>(p-i)</code> works in the same way.</li>
<li>  Mutable pointers can be incremented (or decremented). <code>++p</code> is equivalent to <code>p = p + 1</code>.</li>
<li>  You can subtract a pointer <code>q</code> from another pointer <code>p</code> if the pointers are the same type (point to the same type). The value of <code>(p-q)</code> in C is given in "normal" arithmetic by:
$$(p-q)/sizeof(*p)$$
In other words, if <code>p=q+i</code> then <code>i=p-q</code>.</li>
<li>  Pointers (of the same type) can be compared with the comparison operator: <code>&lt;, &lt;=, ==, !=, &gt;=, &gt;</code>
</li>
</ul>

<h4>
<a id="user-content-pointer-arithmetic-and-arrays" class="anchor" href="#pointer-arithmetic-and-arrays" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pointer arithmetic and arrays</h4>

<p>Pointer arithmetic is useful working with <strong>arrays</strong>.</p>

<p>Recall that for an array <code>a</code>, the value of <code>a</code> is the address of the first element (<code>&amp;a[0]</code>).</p>

<p>Using pointer arithmetic, the address of the second element <code>&amp;a[1]</code> is <code>(a+1)</code>, and it can be references as <code>*(a+1)</code>.</p>

<p><strong>The array indexing syntax [] is an operator that performs pointer arithmetic. <code>a[i]</code> is equivalent to <code>*(a+i)</code></strong></p>

<p>In <strong>array pointer notation</strong>, square brackets <code>[]</code> are not used, and all array elements are accessed through pointer arithmetic.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">sum_array</span>(<span class="pl-k">const</span> <span class="pl-k">int</span> *a, <span class="pl-k">int</span> len) {
    <span class="pl-k">int</span> sum = <span class="pl-c1">0</span>; 
    <span class="pl-k">for</span> (<span class="pl-k">const</span> <span class="pl-k">int</span> *p = a; p &lt; a + len; ++p) {
        sum += *p;
    }
    <span class="pl-k">return</span> sum;
}</pre></div>

<p>Note that the above code behaves identically to the previously defined <code>sum_array</code>:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">sum_array</span>(<span class="pl-k">const</span> <span class="pl-k">int</span> a[], <span class="pl-k">int</span> len) {
    <span class="pl-k">int</span> sum = <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; len; ++i) { 
        sum += a[i];
    }
    <span class="pl-k">return</span> sum;
}
</pre></div>

<p>The choice of notation (pointers or []) is a matter of style and context. You are expected to be comfortable with both.</p>

<p>C makes no distinction between the following two function declarations:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">array_function</span>(<span class="pl-k">int</span> a[], <span class="pl-k">int</span> len) {...} <span class="pl-c">// a[] </span>
<span class="pl-k">int</span> <span class="pl-en">array_function</span>(<span class="pl-k">int</span> *a, <span class="pl-k">int</span> len) {...} <span class="pl-c">// *a</span></pre></div>

<p>In most contexts, there is no practical difference between an array identifier and a (constant) pointer.</p>

<h4>
<a id="user-content-array-map" class="anchor" href="#array-map" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Array map</h4>

<p>Aside from the function pointer parameter syntax, the definition of <code>array_map</code> is straightforward.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// effects: replaces each element a[i] with f(a[i])</span>
<span class="pl-k">void</span> <span class="pl-en">array_map</span>(<span class="pl-k">int</span> (*f)(<span class="pl-k">int</span>), int a[], int len) {
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i=<span class="pl-c1">0</span>; i &lt; len; ++i) {
        a[i] = <span class="pl-c1">f</span>(a[i]);
    }
}</pre></div>

<h4>
<a id="user-content-selection-sort" class="anchor" href="#selection-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Selection sort</h4>

<p>In <strong>selection sort</strong>, the smallest element is selected to be the first element in the new sorted sequence, and then the next smallest element is selected to be the second element, and so on.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">selection_sort</span>(<span class="pl-k">int</span> a[], <span class="pl-k">int</span> len) {
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i=<span class="pl-c1">0</span>; i &lt; len - <span class="pl-c1">1</span>; ++i) {
        <span class="pl-k">int</span> pos = i;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> j = i + <span class="pl-c1">1</span>; j &lt; len; ++j) {
            <span class="pl-k">if</span> (a[j] &lt; a[pos]) {
                pos = j;
            }
        }
        <span class="pl-c1">swap</span>(&amp;a[i], &amp;a[pos]); <span class="pl-c">// see Section 05</span>
    }
}
<span class="pl-c">// Notes:</span>
<span class="pl-c">// i: loops from 0 ... len-2 and represents the</span>
<span class="pl-c">// "next" element to be replaced</span>
<span class="pl-c">// j: loops from i+1 ... len-1 and is "searching"</span>
<span class="pl-c">// for the next smallest element</span>
<span class="pl-c">// pos: position of the "next smallest"</span></pre></div>

<h4>
<a id="user-content-quicksort" class="anchor" href="#quicksort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quicksort</h4>

<p>Quicksort is an example of a "divide &amp; conquer" algorithm.</p>

<p>First, an element is selected as a "pivot" element.</p>

<p>The list is then <strong>partitioned</strong> (divided) into two sub-groups: elements less than (or equal to) the pivot and those greater then the pivot.</p>

<p>Finally, each sub-group is then sorted (conquered).</p>

<p>In our C implementation of quick sort, we:</p>

<ul>
<li>  select the first element of the array as our "pivot"</li>
<li>  move all elements that are larger than the pivot to the back of the array</li>
<li>  move ("swap") the pivot into the correct position</li>
<li>  recursively sort the "smaller than" sub-array and the "larger then" sub-array</li>
</ul>

<p>The core quick sort function <code>quick_sort_range</code> has parameters for the range of elements (<code>first</code> and <code>last</code>) to be sorted, so a wrapper function is quired.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">quick_sort_range</span>(<span class="pl-k">int</span> a[], <span class="pl-k">int</span> first, <span class="pl-k">int</span> last) {
    <span class="pl-k">if</span> (last &lt;= first) <span class="pl-k">return</span>; <span class="pl-c">// length is &lt;= 1</span>
    <span class="pl-k">int</span> pivot = a[first]; <span class="pl-c">// first element is the pivot</span>
    <span class="pl-k">int</span> pos = last; <span class="pl-c">// where to put next larger</span>
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = last; i &gt; first; --i) {
        <span class="pl-k">if</span> (a[i] &gt; pivot) {
            <span class="pl-c1">swap</span>(&amp;a[pos], &amp;a[i]);
            --pos;
        }
    }
    <span class="pl-c1">swap</span>(&amp;a[first], &amp;a[pos]); <span class="pl-c">// put pivot in correct place</span>
    <span class="pl-c1">quick_sort_range</span>(a, first, pos-<span class="pl-c1">1</span>);
    <span class="pl-c1">quick_sort_range</span>(a, pos+<span class="pl-c1">1</span>, last);
}
<span class="pl-k">void</span> <span class="pl-en">quick_sort</span>(<span class="pl-k">int</span> a[], <span class="pl-k">int</span> len) {
    <span class="pl-c1">quick_sort_range</span>(a, <span class="pl-c1">0</span>, len-<span class="pl-c1">1</span>);
}</pre></div>

<h4>
<a id="user-content-binary-search" class="anchor" href="#binary-search" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Binary search</h4>

<p>In Racket, the built-in function <code>member</code> can be used to determine if a list contains an element.</p>

<p>We can write a similar function in C that finds the index of an element in an array:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// find(item, a, len) finds the index of item in a,</span>
<span class="pl-c">// or -1 if it does not exist</span>
<span class="pl-k">int</span> <span class="pl-en">find</span>(<span class="pl-k">int</span> item, <span class="pl-k">const</span> <span class="pl-k">int</span> a[], <span class="pl-k">int</span> len) {
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i=<span class="pl-c1">0</span>; i &lt; len; ++i) {
        <span class="pl-k">if</span> (a[i] == item) {
            <span class="pl-k">return</span> i;
        }
    }
    <span class="pl-k">return</span> -<span class="pl-c1">1</span>;
}</pre></div>

<p>But what if the array was previously sorted?</p>

<p>We can use <strong>binary search</strong> to find the element faster:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">find_sorted</span>(<span class="pl-k">int</span> item, <span class="pl-k">const</span> <span class="pl-k">int</span> a[], <span class="pl-k">int</span> len) {
    <span class="pl-k">int</span> low = <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> high = len-<span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (low &lt;= high) {
        <span class="pl-k">int</span> mid = low + (high - low) / <span class="pl-c1">2</span>;
        <span class="pl-k">if</span> (a[mid] == item) {
            <span class="pl-k">return</span> mid;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (a[mid] &lt; item) {
            low = mid + <span class="pl-c1">1</span>;
        } <span class="pl-k">else</span> {
            high = mid - <span class="pl-c1">1</span>;
        }
    }
    <span class="pl-k">return</span> -<span class="pl-c1">1</span>;
}</pre></div>

<h4>
<a id="user-content-multi-dimensional-data" class="anchor" href="#multi-dimensional-data" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Multi-dimensional data</h4>

<p>All of the arrays seen so far have been one-dimensional arrays.</p>

<p>We can represent multi-dimensional data by "mapping" the higher dimensions done to one.</p>

<p>For example, consider a 2D array with 2 rows and 3 columns.</p>

<pre><code>1 2 3
7 8 9
</code></pre>

<p>We can represent the data in a simple one-dimensional array.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> data[<span class="pl-c1">6</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>};</pre></div>

<p>To access the entry in row <code>r</code> and column <code>c</code>, we simply access the element at <code>data[r*3+c]</code>.</p>

<p>In general, it would be <code>data[row * NUMCOLS + col]</code>.</p>

<h4>
<a id="user-content-fixed-length-arrays" class="anchor" href="#fixed-length-arrays" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fixed-Length arrays</h4>

<p>A significant limitation of an array is that you need to know the length of the array <strong>in advance</strong>.</p>

<p>In some applications, it may be "appropriate" to have a <strong>maximum length</strong> for an array.</p>

<p>In general, maximums should only be used when appropriate:</p>

<ul>
<li>  They are wasteful if the maximum is excessively large</li>
<li>  They are restrictive if the maximum is too small.</li>
</ul>

<p>When working with maximum-length arrays, we need to keep track if </p>

<ul>
<li>  the "actual" length of the array, and</li>
<li>  the maximum possible length.</li>
</ul>

<p>To illustrate fixed-length arrays, we will implement an integer <strong>stack</strong> structure with a maximum length of 100 elements.</p>

<p>The <code>len</code> field will keep track of the actual length of the stack.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> stack {
    <span class="pl-k">int</span> len;
    <span class="pl-k">int</span> maxlen;
    <span class="pl-k">int</span> data[<span class="pl-c1">100</span>];
};</pre></div>

<p>We will need to provide a <code>stack_init</code> function to initialize the structure:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">stack_init</span>(<span class="pl-k">struct</span> stack *s) {
    <span class="pl-c1">assert</span>(s);
    s-&gt;len = <span class="pl-c1">0</span>;
    s-&gt;maxlen = <span class="pl-c1">100</span>;
}</pre></div>

<p>Ignoring the <code>push</code> operation for now, we can write the rest of the stack implementation:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">bool</span> <span class="pl-en">stack_is_empty</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> stack *s) {
    <span class="pl-c1">assert</span>(s);
    <span class="pl-k">return</span> s-&gt;len == <span class="pl-c1">0</span>;
}

<span class="pl-k">int</span> <span class="pl-en">stack_top</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> stack *s) {
    <span class="pl-c1">assert</span>(s);
    <span class="pl-c1">assert</span>(s-&gt;len);
    <span class="pl-k">return</span> s-&gt;data[s-&gt;len - <span class="pl-c1">1</span>];
}

<span class="pl-c">// note: stack_pop returns the element popped</span>
<span class="pl-k">int</span> <span class="pl-en">stack_pop</span>(<span class="pl-k">struct</span> stack *s) {
    <span class="pl-c1">assert</span>(s);
    <span class="pl-c1">assert</span>(s-&gt;len);
    s-&gt;len -= <span class="pl-c1">1</span>;
    <span class="pl-k">return</span> s-&gt;data[s-&gt;len];
}</pre></div>

<p>What happens if we exceed the maximum length when we try to <code>push</code> an element?</p>

<p>There are a few possibilities:</p>

<ul>
<li>  the stack is not modified and an error message is displayed</li>
<li>  a special return value can be used</li>
<li>  an assertion fails (terminating the program)</li>
<li>  the program explicitly <strong>terminates</strong> with an error message</li>
</ul>

<p>Any approach may be appropriate as long as the contract properly documents the behavior.</p>

<p>The <code>exit</code> function (part of <code>&lt;stdlib.h&gt;</code>) stops program execution. It is useful for "fatal" errors.</p>

<p>The argument passed to <code>exit</code> is equivalent to the <code>return</code> value of <code>main</code>.</p>

<p>For convenience, <code>&lt;stdlib.h&gt;</code> defines <code>EXIT_SUCCESS(0)</code> and <code>EXIT_FAILURE</code> (non-zero).</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">if</span> (something_bad) {
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>FATAL ERROR: Something bad happened!<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
    <span class="pl-c1">exit</span>(EXIT_FAILURE);
}</pre></div>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// stack_push(item, s) pushes item onto stack s</span>
<span class="pl-c">// requires: s is a valid stack</span>
<span class="pl-c">// effects: modifies s</span>
<span class="pl-c">// if max stack size is exceeded,</span>
<span class="pl-c">// prints a message and exits</span>
<span class="pl-k">void</span> <span class="pl-en">stack_push</span>(<span class="pl-k">int</span> item, <span class="pl-k">struct</span> stack *s) {
    <span class="pl-c1">assert</span>(s);
    <span class="pl-k">if</span> (s-&gt;len == s-&gt;maxlen) {
        <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>FATAL ERROR: max stack size (<span class="pl-c1">%d</span>) exceeded<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
        ,
        s-&gt;maxlen);
        <span class="pl-c1">exit</span>(EXIT_FAILURE);
    }
    s-&gt;data[s-&gt;len] = item;
    s-&gt;len += <span class="pl-c1">1</span>;
}</pre></div>

<h4>
<a id="user-content-strings" class="anchor" href="#strings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Strings</h4>

<p>There is no built-in C <strong>string</strong> type. The "convention" is that a C string is an <strong>array of characters</strong>, terminated by a <strong>null character</strong>.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> my_string[<span class="pl-c1">4</span>] = {<span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>};</pre></div>

<p>The null character, also known as a null <strong>terminator</strong>, is a <code>char</code> with a value of zero. It is often written as <code>'\0'</code> instead of 0 to improve communication and indicate that a null character is intended.</p>

<p><strong><code>'\0'</code> (ASCII 0) is different than '0' (ASCII 48), which is the character for the symbol zero.</strong></p>

<h4>
<a id="user-content-string-initialization" class="anchor" href="#string-initialization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>String initialization</h4>

<p><code>char</code> arrays also support a double quote (") <strong>initialization</strong> syntax. When combined with the automatic length declaration ([]), the length includes the null terminator.</p>

<p>The following definitions create equivalent 4-character arrays:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> a[] = {<span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>};
<span class="pl-k">char</span> b[] = {<span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>};
<span class="pl-k">char</span> c[<span class="pl-c1">4</span>] = {<span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>};
<span class="pl-k">char</span> d[] = {<span class="pl-c1">99</span>, <span class="pl-c1">97</span>, <span class="pl-c1">116</span>, <span class="pl-c1">0</span>};
<span class="pl-k">char</span> e[<span class="pl-c1">4</span>] = <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span>;
<span class="pl-k">char</span> f[] = <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span>;</pre></div>

<p>This array <strong>initialization</strong> notation is different than the double quote notation used in expressions (e.g., in <code>printf("string")</code>).</p>

<h4>
<a id="user-content-null-termination" class="anchor" href="#null-termination" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Null termination</h4>

<p>With null terminated strings, we do not have to pass the length to every function. It can be automatically determined.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// e_count(s) counts the # of e's and E's in string s</span>
<span class="pl-k">int</span> <span class="pl-en">e_count</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> s[]) {
    <span class="pl-k">int</span> count = <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> i = <span class="pl-c1">0</span>;
    <span class="pl-k">while</span> (s[i]) { <span class="pl-c">// not the null terminator</span>
        <span class="pl-k">if</span> ((s[i] == <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>)||(s[i] == <span class="pl-s"><span class="pl-pds">'</span>E<span class="pl-pds">'</span></span>)) {
            ++count;
        }
        ++i;
    }
    <span class="pl-k">return</span> count;
}</pre></div>

<p>As with "regular" arrays, it is good style to have <code>const</code> parameters to communicate that no changes (mutation) occurs to the string.</p>

<h4>
<a id="user-content-strlen" class="anchor" href="#strlen" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>strlen</h4>

<p>The <code>string</code> library (<code>#include &lt;string.h&gt;</code>) provides many useful functions for processing strings.</p>

<p>The <code>strlen</code> function returns the length of the string, not necessarily the length of the array. It does not include the null character.</p>

<h4>
<a id="user-content-lexicographical-order" class="anchor" href="#lexicographical-order" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Lexicographical order</h4>

<p>Characters can be easily compared (<code>c1&lt;c2</code>) as they are numbers, so the character <strong>order</strong> is determined by the ASCII table.</p>

<p>If we try to compare two strings (<code>s1&lt;s2</code>), C compares their pointers, which is not helpful.</p>

<p>To compare strings we are typically interested in using a <strong>lexicographical order</strong>.</p>

<p>To compare two strings using a <strong>lexicographical order</strong>, we first compare the first character of each string. If they are different, the string with the smaller first character <strong>precedes</strong> the other string. Otherwise (the first characters are the same), the second characters are compared, and so on.</p>

<p>If the end of one string is encountered, it <strong>precedes</strong> the other string. Two strings are equal (the same) if they are the same length and all of their characters are identical.</p>

<p>The following strings are in lexicographical order:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>az<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>cab<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>cabin<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>catastrophe<span class="pl-pds">"</span></span></pre></div>

<p>The <code>&lt;string.h&gt;</code> library function <code>strcmp</code> uses lexicographical ordering.</p>

<p><code>strcmp(s1, s2)</code> returns zero if the strings are identical. If <code>s1</code> precedes <code>s2</code>, it returns a negative integer. Otherwise (<code>s1</code> follows <code>s2</code>) it returns a positive integer.</p>

<p>To compare if two strings are equal, use the <code>strcmp</code> function.</p>

<p>The equality operator (==) only compares the addresses of the strings, and not the contents of the arrays.</p>

<p>Lexicographical orders can be used to compare and sort any sequence of elements (array, lists, ...) and not just strings.</p>

<h4>
<a id="user-content-string-io" class="anchor" href="#string-io" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>String I/O</h4>

<p>The <code>printf</code> placeholder for strings is <code>%s</code>.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> a[] = <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span>;
<span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>the <span class="pl-c1">%s</span> in the hat<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, a);</pre></div>

<p><code>printf</code> prints out characters until the null character is encountered.</p>

<p>When using <code>%s</code> with <code>scanf</code>, it stops reading the string when a "white space" character is encountered (e.g., a space or \n).</p>

<p><code>scanf("%s")</code> is useful for reading in one "word" at a time.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> name[<span class="pl-c1">81</span>];
<span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>What is your first name?<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
<span class="pl-en">scanf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%s</span><span class="pl-pds">"</span></span>, name);</pre></div>

<p>You must be very careful to reserve enough space for the string to be read in, and do not forget the null character.</p>

<p>In this banking example, entering a long command causes C to write characters beyond the length of the <code>command</code> array. Eventually, it overwrites the memory where <code>balance</code> is stored.</p>

<p>This is known as a <strong>buffer overrun</strong> (or buffer overflow). The C language is especially susceptible to buffer overruns, which can cause serious stability and security problems.</p>

<p>In this introductory course, having an array with an appropriate length and using <code>scanf</code> if "good enough".</p>

<p>In practice you would never use this insecure method for reading in a string.</p>

<p>Two additional <code>&lt;string.h&gt;</code> library functions that are useful, but susceptible to buffer overruns are:</p>

<p><code>strcpy(char *dest, const char *src)</code> overwrites the contents of <code>dest</code> with the contents of <code>src</code>.</p>

<p><code>strcat(char *dest, const char *src)</code> copies (appends or concatenates) <code>src</code> to the end of <code>dest</code>.</p>

<p>You should always ensure that the <code>dest</code> array is large enough (and don't forget the null terminator).</p>

<p>While writing to a buffer can cause dangerous buffer overruns, reading an improperly terminated string can also cause problems.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> c[<span class="pl-c1">3</span>] = <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span>; <span class="pl-c">// NOT properly terminated!</span>
<span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%s</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, c);
<span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>The length of c is: <span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, strlen(c));
cat???????????????????
The length of c is: ??</pre></div>

<h4>
<a id="user-content-string-literals" class="anchor" href="#string-literals" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>String literals</h4>

<p>The C strings used in statements (e.g. with <code>printf</code> and <code>scanf</code>) are known as <strong>string literals</strong>.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>i = <span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, i);
<span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>the value of j is <span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, j);</pre></div>

<p>For each string literal, a null-terminated <code>const char</code> array is created in the read-only data section.</p>

<p>In the code, the occurrence of the string literal is replaced with address of the corresponding array.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">foo</span>(<span class="pl-k">int</span> i, <span class="pl-k">int</span> j) {
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>i = <span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, i);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>the value of j is <span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, j);
}</pre></div>

<p>Although no array name is actually given to each literal, it is helpful to imagine that one is:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">const</span> <span class="pl-k">char</span> foo_string_literal_1[] = <span class="pl-s"><span class="pl-pds">"</span>i = <span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
<span class="pl-k">const</span> <span class="pl-k">char</span> foo_string_literal_2[] = <span class="pl-s"><span class="pl-pds">"</span>the value of j is <span class="pl-c1">%d</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;

<span class="pl-k">void</span> <span class="pl-en">foo</span>(<span class="pl-k">int</span> i, <span class="pl-k">int</span> j) {
    <span class="pl-c1">printf</span>(foo_string_literal_1, i);
    <span class="pl-c1">printf</span>(foo_string_literal_2, j);
}</pre></div>

<p>You should not try to modify a string literal. The behavior is undefined, and it causes an error in Seashell.</p>

<h4>
<a id="user-content-arrays-vs-pointers" class="anchor" href="#arrays-vs-pointers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Arrays vs. pointers</h4>

<p>Earlier, we said arrays and pointers are similar but <strong>different</strong>.</p>

<p>Consider the following two string definitions:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">f</span>(<span class="pl-k">void</span>) {
<span class="pl-k">char</span> a[] = <span class="pl-s"><span class="pl-pds">"</span>pointers are not arrays<span class="pl-pds">"</span></span>;
<span class="pl-k">char</span> *p = <span class="pl-s"><span class="pl-pds">"</span>pointers are not arrays<span class="pl-pds">"</span></span>;
...
}</pre></div>

<ul>
<li>  The first reserves space for an initialized 24 character array (a) in the stack frame (24 bytes)</li>
<li>  The second reserves space for a <code>char</code> pointer (p) in the stack frame (8 bytes), initialized to point at a string literal <code>(const char array)</code> created in the read-only data section.</li>
</ul>

<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> a[] = <span class="pl-s"><span class="pl-pds">"</span>pointers are not arrays<span class="pl-pds">"</span></span>;
<span class="pl-k">char</span> *p = <span class="pl-s"><span class="pl-pds">"</span>pointers are not arrays<span class="pl-pds">"</span></span>;
<span class="pl-k">char</span> d[] = <span class="pl-s"><span class="pl-pds">"</span>different string<span class="pl-pds">"</span></span>;</pre></div>

<p><code>a</code> is a <code>char</code> array. The identifier a has a constant value (the address of the array), but the elements of a can be changed.</p>

<div class="highlight highlight-source-c"><pre>a = d; <span class="pl-c">// INVALID</span>
a[<span class="pl-c1">0</span>] = <span class="pl-s"><span class="pl-pds">'</span>P<span class="pl-pds">'</span></span>; <span class="pl-c">// VALID</span></pre></div>

<p><code>p</code> is a <code>char</code> pointer. <code>p</code> is initialized to point at a string literal, but <code>p</code> can be changed to point at any char.</p>

<div class="highlight highlight-source-c"><pre>p[<span class="pl-c1">0</span>] = <span class="pl-s"><span class="pl-pds">'</span>P<span class="pl-pds">'</span></span>; <span class="pl-c">// INVALID (p points at a const literal)</span>
p = d; <span class="pl-c">// VALID</span>
p[<span class="pl-c1">0</span>] = <span class="pl-s"><span class="pl-pds">'</span>D<span class="pl-pds">'</span></span>; <span class="pl-c">// NOW VALID (p points at d)</span></pre></div>

<h4>
<a id="user-content-goals-of-this-section" class="anchor" href="#goals-of-this-section" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Goals of this section</h4>

<p>At the end of this section, you should be able to:</p>

<ul>
<li>  define and initialize arrays and strings</li>
<li>  use iteration to loop through arrays</li>
<li>  use pointer arithmetic</li>
<li>  explain how arrays are represented in the memory model, and how the array index operator [] uses pointer arithmetic to access array elements in constant time</li>
<li>  use both array index notation [] and array pointer notation and convert between the two</li>
<li>  use fixed-length arrays</li>
<li>  describe insertion sort, quicksort and binary search on a sorted array</li>
<li>  represent multi-dimensional data in a single-dimensional array</li>
<li>  explain and demonstrate the use of the null termination convention on strings</li>
<li>  explain string literals and the difference between defining a string array and a string pointer</li>
<li>  sort a string or sequence lexicographically</li>
<li>  use I/O with strings and explain the consequences of buffer overruns</li>
<li>  use <code>&lt;string.h&gt;</code> library functions (when provided with a well documented interface)</li>
</ul>
</article></body></html>