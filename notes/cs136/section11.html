<!DOCTYPE html><html><head><meta charset="utf-8"><style>@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff');
}

* {
    box-sizing: border-box;
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
}

body .markdown-body {
    padding: 45px;
    border: 1px solid #ddd;
    border-radius: 3px;
    word-wrap: break-word;
}

pre {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body {
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  color: #333;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body strong {
  font-weight: bold;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body input {
  font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

.markdown-body a {
  color: #4078c0;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before {
  display: table;
  content: "";
}

.markdown-body hr:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body .select::-ms-expand {
  opacity: 0;
}

.markdown-body .octicon {
  font: normal normal normal 16px/1 octicons-anchor;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.markdown-body .octicon-link:before {
  content: '\f05c';
}

.markdown-body:before {
  display: table;
  content: "";
}

.markdown-body:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .anchor {
  display: inline-block;
  padding-right: 2px;
  margin-left: -18px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #000;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h1 .anchor {
  line-height: 1;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 .anchor {
  line-height: 1;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h3 .anchor {
  line-height: 1.2;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h4 .anchor {
  line-height: 1.2;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h5 .anchor {
  line-height: 1.1;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body h6 .anchor {
  line-height: 1.1;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

.markdown-body code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .pl-c {
  color: #969896;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #0086b3;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #795da3;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #333;
}

.markdown-body .pl-ent {
  color: #63a35c;
}

.markdown-body .pl-k {
  color: #a71d5d;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #183691;
}

.markdown-body .pl-v {
  color: #ed6a43;
}

.markdown-body .pl-id {
  color: #b52a1d;
}

.markdown-body .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

.markdown-body .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

.markdown-body .pl-ml {
  color: #693a17;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

.markdown-body .pl-mq {
  color: #008080;
}

.markdown-body .pl-mi {
  color: #333;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #333;
  font-weight: bold;
}

.markdown-body .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

.markdown-body .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

.markdown-body .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

.markdown-body .pl-mo {
  color: #1d3e81;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .plan-price-unit {
  color: #767676;
  font-weight: normal;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

.markdown-body .plan-choice {
  padding: 15px;
  padding-left: 40px;
  display: block;
  border: 1px solid #e0e0e0;
  position: relative;
  font-weight: normal;
  background-color: #fafafa;
}

.markdown-body .plan-choice.open {
  background-color: #fff;
}

.markdown-body .plan-choice.open .plan-choice-seat-breakdown {
  display: block;
}

.markdown-body .plan-choice-free {
  border-radius: 3px 3px 0 0;
}

.markdown-body .plan-choice-paid {
  border-radius: 0 0 3px 3px;
  border-top: 0;
  margin-bottom: 20px;
}

.markdown-body .plan-choice-radio {
  position: absolute;
  left: 15px;
  top: 18px;
}

.markdown-body .plan-choice-exp {
  color: #999;
  font-size: 12px;
  margin-top: 5px;
}

.markdown-body .plan-choice-seat-breakdown {
  margin-top: 10px;
  display: none;
}

.markdown-body :checked+.radio-label {
  z-index: 1;
  position: relative;
  border-color: #4078c0;
}
</style><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: false
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false
});
</script>
<title>section11</title></head><body><article class="markdown-body"><h1>
<a id="user-content-section-11-linked-data-structures" class="anchor" href="#section-11-linked-data-structures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Section 11: Linked Data Structures</h1>

<h4>
<a id="user-content-linked-lists" class="anchor" href="#linked-lists" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Linked lists</h4>

<p>Racket's like type is more commonly known as a <strong>linked list</strong></p>

<p><a href="https://camo.githubusercontent.com/656ff8c5510937bf70b9ae8b0e77117165b3e79b/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f73656331317067322e504e47" target="_blank"><img src="https://camo.githubusercontent.com/656ff8c5510937bf70b9ae8b0e77117165b3e79b/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f73656331317067322e504e47" alt="linked list" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg2.PNG" style="max-width:100%;"></a></p>

<p>Each <strong>node</strong> contains an <strong>item</strong> and a <strong>link</strong> (pointer) to the <strong>next</strong> node in the list.</p>

<p>The last node's link contains a special <strong>sentinel value</strong> to indicate it is the last node.</p>

<p>A linked list is usually represent as a link to the <strong>front</strong> of the list.</p>

<p><a href="https://camo.githubusercontent.com/33438e4eca9f5cb5ea33d10f1d094009ff7e5075/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f73656331317067332e504e47" target="_blank"><img src="https://camo.githubusercontent.com/33438e4eca9f5cb5ea33d10f1d094009ff7e5075/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f73656331317067332e504e47" alt="linked list front" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg3.PNG" style="max-width:100%;"></a></p>

<p>Unlike arrays, linked list nodes are not arranged sequentially in memory. In general, there is no convenient way to "jump" to the $i$-th element in a linked list. The linked list must be <strong>traversed</strong> from the front. Traversing a linked list is $O(n)$.</p>

<p>A significant advantage of a linked list is that its length can easily change, and the length does not need to be known in advance.</p>

<p>The memory for each node is allocated dynamically.</p>

<h4>
<a id="user-content-functional-vs-imperative-approach" class="anchor" href="#functional-vs-imperative-approach" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Functional vs. Imperative approach</h4>

<p>The core concept of a linked list data structure is independent of any single paradigm.</p>

<p>However, the approach used to <strong>implement</strong> and write functions that process linked lists are very different.</p>

<p>Programming with linked lists further illustrates the differences between the two paradigms.</p>

<h4>
<a id="user-content-dynamic-memory-in-racket" class="anchor" href="#dynamic-memory-in-racket" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dynamic memory in Racket</h4>

<p>Racket uses dynamic memory, but it is mostly <em>hidden</em> from the programmer.</p>

<p>The <code>cons</code> function dynamically creates a <strong>new</strong> linked list node.</p>

<p>The <code>list</code> function and quote list notation <code>'(1 2 3)</code> implicitly use <code>cons</code>.</p>

<p>The only other method of using dynamic memory in Racket is the constructor to <code>make</code> a <strong>new</strong> structure.</p>

<p>Knowing how <code>cons</code> uses dynamic memory, consider how the following Racket function <code>sqr-list</code> constructs a <strong>new list</strong></p>

<div class="highlight highlight-source-racket"><pre>(<span class="pl-en">define</span> (sqr-list lst)
(<span class="pl-en">cond</span>   [(empty? lst) empty]
[<span class="pl-en">else</span> (cons (sqr (first lst) (sqr-list (rest lst))))]))

(<span class="pl-en">define</span> a '(<span class="pl-c1">10</span> <span class="pl-c1">3</span> <span class="pl-c1">5</span> <span class="pl-c1">7</span>))
(<span class="pl-en">define</span> b (sqr-list a))</pre></div>

<p><a href="https://camo.githubusercontent.com/2fd777cfc6e334556325e6faa89c50bbd3e1f1fe/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f73656331317067372e504e47" target="_blank"><img src="https://camo.githubusercontent.com/2fd777cfc6e334556325e6faa89c50bbd3e1f1fe/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f73656331317067372e504e47" alt="linked list racket" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg7.PNG" style="max-width:100%;"></a></p>

<p>In the functional programming paradigm, this is the only sensical meaning, because there is no mutation.</p>

<p>In the imperative programming paradigm, a "square list" function is more likely to <strong>mutate</strong> an existing list instead of producing a new list.</p>

<blockquote>
<p>In practice, most imperative list functions perform mutation. If the caller wants a new list (instead of mutating an existing one), they can first make a copy of the original list and then mutate the new copy.</p>
</blockquote>

<h4>
<a id="user-content-mixing-paradigms" class="anchor" href="#mixing-paradigms" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Mixing paradigms</h4>

<p>Problems may arise if we naively use the functional paradigm in an imperative environment without considering the consequences.</p>

<p>This is especially important in C, where there is no garbage collector.</p>

<table>
<thead>
<tr>
<th>Functional (Racket)</th>
<th>Imperative (C)</th>
</tr>
</thead>
<tbody>
<tr>
<td>no mutation</td>
<td>mutation</td>
</tr>
<tr>
<td>garbage collector</td>
<td>no garbage collector</td>
</tr>
<tr>
<td>hidden pointers</td>
<td>explicit pointers</td>
</tr>
</tbody>
</table>

<p>The following example highlights the potential problems.</p>

<p>Recall the <code>insert</code> function used in Racket's <code>insertion sort</code>.</p>

<div class="highlight highlight-source-racket"><pre><span class="pl-c">;; (insert n slon) inserts n into a sorted list of numbers</span>
(<span class="pl-en">define</span> (insert n slon)
(cons   [(empty? slon) (cons n empty)]
[(&lt;= n (first slon)) (cons n slon)]
[<span class="pl-en">else</span> (cons (first slon) (insert n (rest slon)))]))

(<span class="pl-en">define</span> a '(<span class="pl-c1">10</span> <span class="pl-c1">20</span> <span class="pl-c1">50</span> <span class="pl-c1">100</span>))
(<span class="pl-en">define</span> b (insert <span class="pl-c1">30</span> a))</pre></div>

<p><a href="https://camo.githubusercontent.com/a12817dbc83560f433261332256519031a1c3c67/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706731302e504e47" target="_blank"><img src="https://camo.githubusercontent.com/a12817dbc83560f433261332256519031a1c3c67/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706731302e504e47" alt="racket insert linked list" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg10.PNG" style="max-width:100%;"></a></p>

<p>The lists <strong>share the last two nodes</strong></p>

<p>In Racket this behavior is completely transparent because there is <strong>no mutation</strong>, and there is ad <strong>garbage collector</strong>.</p>

<p>In an imperative language like C, this configuration is problematic.</p>

<ul>
<li>  If we apply a mutative function such as "square list" on <code>a</code>, then some of the elements of <code>b</code> will unexpectedly change.</li>
<li>  If we explicitly <code>free</code> all of the memory for list <code>a</code>, then list <code>b</code>will become invalid.</li>
</ul>

<p>List functions that perform computations and do not modify the list (or produce a new list) work well in both paradigms.</p>

<p>If a function mutates a list (or produces a "new" list), you should use caution to ensure that the result will not create further problems.</p>

<blockquote>
<p>In Racket, lists are immutable, and there is a special <code>mcons</code> function to generate a mutable list.
In the Scheme language, lists are mutable. This is one of the significant differences between Racket and Scheme.</p>
</blockquote>

<h4>
<a id="user-content-linked-lists-in-c" class="anchor" href="#linked-lists-in-c" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Linked lists in C</h4>

<p>There is no "official" way of implementing a linked list in C.</p>

<p>In this section we present a typical linked list structure that uses a <strong>wrapper</strong> strategy.</p>

<p>First, we declare a <em>linked list node</em> (<code>llnode</code>) that stores an "item" and a link (pointer) to the next node.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> llnode {
    <span class="pl-k">int</span> item;
    <span class="pl-k">struct</span> llnode *next;
};</pre></div>

<p>A C structure can contain a <em>pointer</em> to its own structure type. This is the first <strong>recursive data structure</strong> we have seen in C.</p>

<p>For the last pointer in the list (or an empty list) we use a <code>NULL</code> pointer as a sentinel value.</p>

<p>As mentioned previously, we use a <strong>wrapper</strong> strategy, where we wrap the link to the first node inside of another structure (<code>llist</code>).</p>

<p>This makes some of the following code more straightforward.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> llist {
    <span class="pl-k">struct</span> llnode *front;
}</pre></div>

<p>We also define a <code>list_create</code> function to create an empty list.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> llist *<span class="pl-en">list_create</span>(<span class="pl-k">void</span>) {
    <span class="pl-k">struct</span> llist *lst = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> llist));
    list-&gt;front = <span class="pl-c1">NULL</span>;
    <span class="pl-k">return</span> lst;
}</pre></div>

<p>Of course, we need to add items to our linked list.</p>

<p>The following code creates a new node, and insert it at the front of the list.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">add_front</span>(<span class="pl-k">int</span> i, <span class="pl-k">struct</span> llist *lst) {
    <span class="pl-k">struct</span> llnode *node = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> llnode));
    node-&gt;item = i;
    node-&gt;next = lst-&gt;front;
    lst-&gt;front = node;
}</pre></div>

<h4>
<a id="user-content-traversing-a-list" class="anchor" href="#traversing-a-list" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Traversing a list</h4>

<p>We can traverse a list <strong>iteratively</strong> or <strong>recursively</strong>.</p>

<p>When iterating through a list, we typically use a (<code>llnode</code>) pointer to keep track of the "current" node.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">length</span>(<span class="pl-k">struct</span> llist *lst) {
    <span class="pl-k">int</span> length = <span class="pl-c1">0</span>;
    <span class="pl-k">struct</span> llnode *node = lst-&gt;front;
    <span class="pl-k">while</span> (node) {
        ++length;
        node = node-&gt;next;
    }
    <span class="pl-k">return</span> length;
}</pre></div>

<p>Remember (<code>node</code>) will be false at the end of the list (<code>NULL</code>)</p>

<p>When using <strong>recursion</strong>, remember to recurse on a node (<code>llnode</code>) not the wrapper list itself (<code>llist</code>).</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">length_nodes</span>(<span class="pl-k">struct</span> llnode *node) {
    <span class="pl-k">if</span> (node == <span class="pl-c1">NULL</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    <span class="pl-k">return</span> <span class="pl-c1">1</span> + <span class="pl-c1">length_nodes</span>(node-&gt;next);
}</pre></div>

<p>You can write a corresponding wrapper function:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">list_length</span>(<span class="pl-k">struct</span> llist *lst) {
    <span class="pl-k">return</span> <span class="pl-c1">length_nodes</span>(lst-&gt;front);
}</pre></div>

<p>or call the recursive function directly on the front of the list.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> len = length_nodes(lst-&gt;front);</pre></div>

<h4>
<a id="user-content-destroying-a-list" class="anchor" href="#destroying-a-list" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Destroying a list</h4>

<p>In C, we don't have a <em>garbage collector</em>, so we must be able to <code>free</code> our linked list. We need to free every node and the list wrapper.</p>

<p>When using an iterative approach, we are going to need two node pointers to ensure that the nodes are <code>freed</code> in a safe way.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">list_destroy</span>(<span class="pl-k">struct</span> llist *lst) {
    <span class="pl-k">struct</span> llnode *curnode = lst-&gt;front;
    <span class="pl-k">while</span> (curnode) {
        <span class="pl-k">struct</span> llnode *nextnode = curnode-&gt;next;
        <span class="pl-c1">free</span>(curnode);
        curnode = nextnode;
    }
    <span class="pl-c1">free</span>(lst);
}</pre></div>

<p>For more advanced list traversal functions, the technique of maintaining more than one node pointer is often necessary. It may take some practice and diagrams to master this technique.</p>

<p>For extra practice, consider this slightly different implementation:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">list_destroy</span>(<span class="pl-k">struct</span> llist *lst) {
    <span class="pl-k">struct</span> llnode *curnode = lst-&gt;front;
    <span class="pl-k">while</span> (curnode) {
        <span class="pl-k">struct</span> llnode *backup = curnode;
        curnode = curnode-&gt;next;
        <span class="pl-c1">free</span>(backup);
    }
    <span class="pl-c1">free</span>(lst);
}</pre></div>

<p>With a recursive approach, it is more convenient to free the rest of list before we <code>free</code> the first node.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">free_nodes</span>(<span class="pl-k">struct</span> llnode *node) {
    <span class="pl-k">if</span> (node) {
        <span class="pl-c1">free_nodes</span>(node-&gt;next);
        <span class="pl-c1">free</span>(node);
    }
}

<span class="pl-k">void</span> <span class="pl-en">list_destroy</span>(<span class="pl-k">struct</span> llist *lst) {
    <span class="pl-c1">free_nodes</span>(lst-&gt;front);
    <span class="pl-c1">free</span>(lst);
}</pre></div>

<h4>
<a id="user-content-duplicating-a-list" class="anchor" href="#duplicating-a-list" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Duplicating a list</h4>

<p>Previously, we used the "square list" function to illustrate the differences between the functional and imperative paradigms.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// list_sqr(lst) squares each item in lst</span>
<span class="pl-c">// effects: modifies lst</span>

<span class="pl-k">void</span> <span class="pl-en">list_sqr</span>(<span class="pl-k">struct</span> llist *lst) {
    <span class="pl-k">struct</span> llnode *node = lst-&gt;front;
    <span class="pl-k">while</span> (node) {
        node-&gt;item *= node-&gt;item;
        node = node-&gt;next;
    }
}</pre></div>

<p>But what if we do want a new list that is squared instead of mutating an existing one?</p>

<p>One solution is to provide a <code>list_dup</code> function, that makes a duplicate of an existing list.</p>

<p>The recursive function is the most straightforward.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">node_dup</span>(<span class="pl-k">struct</span> llnode *node, <span class="pl-k">struct</span> llist *newlist) {
    <span class="pl-k">if</span> (node) {
        <span class="pl-c1">node_dup</span>(node-&gt;next, newlist);
        <span class="pl-c1">add_front</span>(node-&gt;item, newlist);
    }
}

<span class="pl-k">struct</span> llist *<span class="pl-en">list_dup</span>(<span class="pl-k">struct</span> llist *oldlist) {
    <span class="pl-k">struct</span> llist *newlist = <span class="pl-c1">list_create</span>();
    <span class="pl-c1">node_dup</span>(oldlist-&gt;front, newlist);
    <span class="pl-k">return</span> newlist;
}</pre></div>

<p>The iterative solution is more complicated:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> llist *<span class="pl-en">list_dup</span>(<span class="pl-k">struct</span> llist *oldlist) {
    <span class="pl-k">struct</span> llist *newlist = <span class="pl-c1">list_create</span>();
    <span class="pl-k">struct</span> llnode *oldnode = oldlist-&gt;front;
    <span class="pl-k">struct</span> llnode *prevnode = <span class="pl-c1">NULL</span>;
    <span class="pl-k">while</span> (oldnode) {
        <span class="pl-k">struct</span> llnode *newnode = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> llnode));
        newnode-&gt;item = oldnode-&gt;item;
        newnode-&gt;next = <span class="pl-c1">NULL</span>;
        <span class="pl-k">if</span> (prevnode) {
            prevnode-&gt;next = newnode;
        } <span class="pl-k">else</span> {
            newlist-&gt;front = newnode;
        }
        prevnode = newnode;
        oldnode = oldnode-&gt;next;
    }
    <span class="pl-k">return</span> newlist;
}</pre></div>

<h4>
<a id="user-content-imperative-insert" class="anchor" href="#imperative-insert" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Imperative insert</h4>

<p>Earlier, we saw how the Racket (functional) implementation of insert would be problematic in C.</p>

<p>For an <code>insert</code> function in C, we expect the following behavior:</p>

<p><a href="https://camo.githubusercontent.com/1d7c7bd97d06bca95794fa956f6a7a09103048b1/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706732365f312e504e47" target="_blank"><img src="https://camo.githubusercontent.com/1d7c7bd97d06bca95794fa956f6a7a09103048b1/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706732365f312e504e47" alt="racket insert" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg26_1.PNG" style="max-width:100%;"></a></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">insert</span>( <span class="pl-c1">5</span>, a);
<span class="pl-en">insert</span>(<span class="pl-c1">30</span>, a);</pre></div>

<p><a href="https://camo.githubusercontent.com/c1ad7c98508436dd1effb30cc0c169eb54dbb0b0/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706732365f322e504e47" target="_blank"><img src="https://camo.githubusercontent.com/c1ad7c98508436dd1effb30cc0c169eb54dbb0b0/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706732365f322e504e47" alt="racket insert" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg26_2.PNG" style="max-width:100%;"></a></p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// insert(i, slst) inserts i into list slst</span>
<span class="pl-c">// effects: modifies slst</span>
<span class="pl-c">// time: O(n), where n is the length of slst</span>

<span class="pl-k">void</span> <span class="pl-en">insert</span>(<span class="pl-k">int</span> i, <span class="pl-k">struct</span> llist *slst) {
    <span class="pl-k">if</span> (slst-&gt;front == <span class="pl-c1">NULL</span> || i &lt; slst-&gt;front-&gt;item) {
        <span class="pl-c1">add_front</span>(i, slst);
    } <span class="pl-k">else</span> {
        <span class="pl-k">struct</span> llnode *prevnode = slst-&gt;front;
        <span class="pl-k">while</span> (prevnode-&gt;next &amp;&amp; i &gt; prevnode-&gt;next-&gt;item) {
            prevnode = prevnode-&gt;next;
        }
        <span class="pl-k">struct</span> llnode *newnode = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> llnode));
        newnode-&gt;item = i;
        newnode-&gt;next = prevnode-&gt;next;
        prevnode-&gt;next = newnode;
    }
}</pre></div>

<h4>
<a id="user-content-removing-nodes" class="anchor" href="#removing-nodes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Removing nodes</h4>

<p>In Racket, the <code>rest</code> function does not actually remove the first element, instead it provides a pointer to the next node.</p>

<p>In C, we can implement a function that removes the first node.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">remove_front</span>(<span class="pl-k">struct</span> llist *lst) {
    <span class="pl-c1">assert</span>(lst-&gt;front);
    <span class="pl-k">int</span> retval = lst-&gt;front-&gt;item;
    <span class="pl-k">struct</span> llnode *backup = lst-&gt;front;
    lst-&gt;front = lst-&gt;front-&gt;next;
    <span class="pl-c1">free</span>(backup);
    <span class="pl-k">return</span> retval;
}</pre></div>

<p>Instead of returning nothing (<code>void</code>), it is more useful to return the value of the item being removed.</p>

<p>Removing a node from an arbitrary list position is more complicated.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// remove_item(i, lst) removes the first occurrence of i in lst</span>
<span class="pl-c">//   return value indicates if item is successfully removed</span>

<span class="pl-k">bool</span> <span class="pl-en">remove_item</span>(<span class="pl-k">int</span> i, <span class="pl-k">struct</span> llist *lst) {
    <span class="pl-k">if</span> (lst-&gt;front == <span class="pl-c1">NULL</span>) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    <span class="pl-k">if</span> (lst-&gt;front-&gt;item == i) {
        <span class="pl-c1">remove_front</span>(lst);
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">struct</span> llnode *prevnode = lst-&gt;front;
    <span class="pl-k">while</span> (prevnode-&gt;next &amp;&amp; i != prevnode-&gt;next-&gt;item) {
        prevnode = prevnode-&gt;next;
    }
    <span class="pl-k">if</span> (prevnode-&gt;next == <span class="pl-c1">NULL</span>) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    <span class="pl-k">struct</span> llnode *backup = prevnode-&gt;next;
    prevnode-&gt;next = prevnode-&gt;next-&gt;next;
    <span class="pl-c1">free</span>(backup);
    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
}</pre></div>

<h4>
<a id="user-content-revisiting-the-wrapper-approach" class="anchor" href="#revisiting-the-wrapper-approach" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Revisiting the wrapper approach</h4>

<p>Throughout these slides we have used a <strong>wrapper</strong> strategy, where we wrap the link to the first node inside of another structure (<code>llist</code>).</p>

<p>Some of the advantages of this strategy are:</p>

<ul>
<li>  cleaner function interfaces</li>
<li>  reduced need for double pointers</li>
<li>  reinforces the imperative paradigm</li>
<li>  less susceptible to misuse and list corruption</li>
</ul>

<p>The disadvantages of the wrapper approach include:</p>

<ul>
<li>  slightly more awkward recursive implementations</li>
<li>  extra "special case" code around the first term</li>
</ul>

<p>However, there is one more significant advantage of the wrapper approach: <strong>additional information</strong> can be stored in the list structure.</p>

<p>Consider that we are writing an application where the <code>length</code> of a linked list will be queried often.</p>

<p>Typically, finding the length of a linked list is $O(n)$.</p>

<p>However, we can store (or "cache") the length in the wrapper structure, so the length can be retrieved in $O(1)$ time.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> llist {
    <span class="pl-k">struct</span> llnode *front;
    <span class="pl-k">int</span> length;
};</pre></div>

<p>Naturally, other list functions would have to update the <code>length</code> as necessary</p>

<ul>
<li>  <code>list_create</code> would initialize length to zero</li>
<li>  <code>add_front</code> would increment length</li>
<li>  <code>remove_front</code> would decrement length</li>
</ul>

<h4>
<a id="user-content-data-integrity" class="anchor" href="#data-integrity" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data integrity</h4>

<p>The introduction of the <code>length</code> field to the linked list may seem like a great idea to improve efficiency.</p>

<p>However, it introduces new ways that the structure can be corrupted. What if the <code>lenth</code> field does not accurately reflect the true length?</p>

<p>For example, imagine that someone implements the <code>remove_item</code> function, but forgets to update the <code>length</code> field?</p>

<p>Or a naive coder may think that the following statement removes all of the codes from the list.</p>

<div class="highlight highlight-source-c"><pre>lst-&gt;length = <span class="pl-c1">0</span>;</pre></div>

<p><strong>Whenever the same information is stored in more than one way, it is susceptible to integrity (consistency) issues.</strong></p>

<p>Advanced testing methods can often find these types of errors, but you must exercise caution.</p>

<p>If data integrity is an issue, it is often better to repackage the data structure as a separate ADT module and only provide interface functions to the client.</p>

<p>This is an example of <strong>security</strong> (protecting the client from themselves).</p>

<h4>
<a id="user-content-queue-adt" class="anchor" href="#queue-adt" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Queue ADT</h4>

<p>A queue is like a "lineup", where new items go to the "back" of the line, and the items are removed from the "front" of the line. While a stack is LIFO, a queue is FIFO (first in, first out).</p>

<p>Typical queue ADT operations:</p>

<ul>
<li>  <code>add_back</code>: adds an item to the end of the queue</li>
<li>  <code>remove_front</code>: removes the item at the front of the queue</li>
<li>  <code>front</code>: returns the item at the front</li>
<li>  <code>is_empty</code>: determines if the queue is empty</li>
</ul>

<p>A Stack ADT can be easily implemented using a dynamic array or with a linked list.</p>

<p>When it is possible to implement a Queue ADT with a dynamic array, the implementation is a bit tricky. Queues are typically implemented with linked lists.</p>

<p>The only concern is that an add_back operation is normally $O(n)$.</p>

<p>However, if we maintain a pointer to the back (last element) of the list, in addition to a pointer to the front of the list, we can implement <code>add_back</code> in $O(1)$.</p>

<blockquote>
<p>Maintaining a <code>back</code> pointer is a popular modification to a traditional linked list, and another reason to use a wrapper.</p>
</blockquote>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// queue.h</span>
<span class="pl-c">// all operations are O(1) (except destroy)</span>

<span class="pl-k">struct</span> queue;

<span class="pl-k">struct</span> queue *<span class="pl-en">queue_create</span>(<span class="pl-k">void</span>);

<span class="pl-k">void</span> <span class="pl-en">queue_add_back</span>(<span class="pl-k">int</span> i, <span class="pl-k">struct</span> queue *q);

<span class="pl-k">int</span> <span class="pl-en">queue_remove_front</span>(<span class="pl-k">struct</span> queue *q);

<span class="pl-k">int</span> <span class="pl-en">queue_front</span>(<span class="pl-k">struct</span> queue *q);

<span class="pl-k">bool</span> <span class="pl-en">queue_is_empty</span>(<span class="pl-k">struct</span> queue *q);

<span class="pl-k">void</span> <span class="pl-en">queue_destroy</span>(<span class="pl-k">struct</span> queue *q);</pre></div>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// queue.c (IMPLEMENTATION)</span>

<span class="pl-k">struct</span> llnode {
    <span class="pl-k">int</span> item;
    <span class="pl-k">struct</span> llnode *next;
};

<span class="pl-k">struct</span> queue {
    <span class="pl-k">struct</span> llnode *front;
    <span class="pl-k">struct</span> llnode *back;
};

<span class="pl-k">struct</span> queue *<span class="pl-en">queue_create</span>(<span class="pl-k">void</span>) {
    <span class="pl-k">struct</span> queue *q = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> queue));
    q-&gt;front = <span class="pl-c1">NULL</span>;
    q-&gt;back = <span class="pl-c1">NULL</span>;
    <span class="pl-k">return</span> q;
}

<span class="pl-k">void</span> <span class="pl-en">queue_add_back</span>(<span class="pl-k">int</span> i, <span class="pl-k">struct</span> queue *q) {
    <span class="pl-k">struct</span> llnode *node = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> llnode));
    node-&gt;item = i;
    node-&gt;next = <span class="pl-c1">NULL</span>;
    <span class="pl-k">if</span> (q-&gt;front == <span class="pl-c1">NULL</span>) {
        q-&gt;front = node;
    } <span class="pl-k">else</span> {
        q-&gt;back-&gt;next = node;
    }
    q-&gt;back = node;
}

<span class="pl-k">int</span> <span class="pl-en">queue_remove_front</span> (<span class="pl-k">struct</span> queue *q) {
    <span class="pl-c1">assert</span>(q-&gt;front);
    <span class="pl-k">int</span> retval = q-&gt;front-&gt;item;
    <span class="pl-k">struct</span> llnode *backup = q-&gt;front;
    q-&gt;front = q-&gt;front-&gt;next;
    <span class="pl-c1">free</span>(backup);
    <span class="pl-k">if</span> (q-&gt;front == <span class="pl-c1">NULL</span>) q-&gt;back = <span class="pl-c1">NULL</span>;
    <span class="pl-k">return</span> retval;
}

<span class="pl-k">int</span> <span class="pl-en">queue_front</span>(<span class="pl-k">struct</span> queue *q) {
    <span class="pl-c1">assert</span>(q-&gt;front);
    <span class="pl-k">return</span> q-&gt;front-&gt;item;
}
<span class="pl-k">bool</span> <span class="pl-en">queue_is_empty</span>(<span class="pl-k">struct</span> queue *q) {
    <span class="pl-k">return</span> q-&gt;front == <span class="pl-c1">NULL</span>;
}
<span class="pl-k">void</span> <span class="pl-en">queue_destroy</span>(<span class="pl-k">struct</span> queue *q) {
    <span class="pl-k">while</span> (!<span class="pl-c1">queue_is_empty</span>(q)) {
        <span class="pl-c1">queue_remove_front</span>(q);
    }
    <span class="pl-c1">free</span>(q);
}</pre></div>

<h4>
<a id="user-content-node-augmentation-strategy" class="anchor" href="#node-augmentation-strategy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Node augmentation strategy</h4>

<p>In an <strong>node augmentation strategy</strong>, each node is augmented to include additional information about the node or the structure.</p>

<p>For example, a <strong>dictionary</strong> node can contain both a <em>key</em> (item) and a corresponding <em>value</em>.</p>

<p>Or for a <strong>priority queue</strong>, each node can additionally store the priority of the item.</p>

<p>The most common node augmentation for a linked list is to create a <strong>double linked list</strong>, where each node also contains a pointer to the previous node. When combined with <code>back</code> pointer in a wrapper, a double linked list can add or remove from the front and back in $O(1)$ time.</p>

<p><a href="https://camo.githubusercontent.com/36aa39f26136d65e3d1f56974dd564cc2ff76692/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706734332e504e47" target="_blank"><img src="https://camo.githubusercontent.com/36aa39f26136d65e3d1f56974dd564cc2ff76692/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706734332e504e47" alt="double linked list" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg43.PNG" style="max-width:100%;"></a></p>

<p>Many programming environments provide a Double-Ended Queue (dequeue or deque) ADT, which can be used as a stack or a Queue ADT.</p>

<h4>
<a id="user-content-trees" class="anchor" href="#trees" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Trees</h4>

<p>At the implementation level, <strong>trees</strong> are very similar to linked lists.</p>

<p>Each node can <em>link</em> to more than one node.</p>

<p><a href="https://camo.githubusercontent.com/a1421834c71348ba0de016fb573f14bc2e29e9de/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706734342e504e47" target="_blank"><img src="https://camo.githubusercontent.com/a1421834c71348ba0de016fb573f14bc2e29e9de/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706734342e504e47" alt="tree" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg44.PNG" style="max-width:100%;"></a></p>

<h4>
<a id="user-content-tree-terminology" class="anchor" href="#tree-terminology" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tree terminology</h4>

<ul>
<li>  the <strong>root node</strong> has no <strong>parent</strong>
</li>
<li>  all other nodes have exactly one parent</li>
<li>  nodes can have multiple <strong>children</strong>
</li>
<li>  in a <strong>binary tree</strong>, each node has at most two children</li>
<li>  a <strong>leaf node</strong> has no children</li>
<li>  the <strong>height</strong> of a tree is the maximum possible number of nodes from the root to a leaf (inclusive)B</li>
<li>  the height of an empty tree is zero</li>
</ul>

<h4>
<a id="user-content-binary-search-trees-bsts" class="anchor" href="#binary-search-trees-bsts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Binary Search Trees (BSTs)</h4>

<p>Binary Search Tree (BST) enforce the <strong>ordering property</strong>: for every node with an item $i$, all items in the left child subtree are less than $i$, and all items in the right child subtree are greater than $i$.</p>

<p><a href="https://camo.githubusercontent.com/a1421834c71348ba0de016fb573f14bc2e29e9de/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706734342e504e47" target="_blank"><img src="https://camo.githubusercontent.com/a1421834c71348ba0de016fb573f14bc2e29e9de/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706734342e504e47" alt="tree" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg44.PNG" style="max-width:100%;"></a></p>

<h4>
<a id="user-content-mixing-paradigms-1" class="anchor" href="#mixing-paradigms-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Mixing paradigms</h4>

<p>As with linked lists, we have to be careful not to mix functional and imperative paradigms, especially when adding nodes. The following example visualizes what Racket produces when a node (45) is added to the BST illustrated earlier.</p>

<p><a href="https://camo.githubusercontent.com/93a3f9d6c2630f2dc33937541b0cd9537f2049fd/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706734372e504e47" target="_blank"><img src="https://camo.githubusercontent.com/93a3f9d6c2630f2dc33937541b0cd9537f2049fd/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706734372e504e47" alt="racket tree" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg47.PNG" style="max-width:100%;"></a></p>

<p>Our BST node (<code>bstnode</code>) is very similar to our linked list node definition.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> bstnode {
    <span class="pl-k">int</span> item;
    <span class="pl-k">struct</span> bstnode *left;
    <span class="pl-k">struct</span> bstnode *right;
};

<span class="pl-k">struct</span> bst {
    <span class="pl-k">struct</span> bstnode *root;
};</pre></div>

<p>As with linked lists, we will need a function to create a new BST.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// bst_create() creates a new BST</span>
<span class="pl-c">// effects: allocates memory: call bst_destroy</span>
<span class="pl-k">struct</span> bst *<span class="pl-en">bst_create</span>(<span class="pl-k">void</span>) {
    <span class="pl-k">struct</span> bst *t = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> bst));
    t-&gt;root = <span class="pl-c1">NULL</span>;
    <span class="pl-k">return</span> t;
}</pre></div>

<p>Before writing code to insert a new node, first we write a helper to create a new leaf node.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> bstnode *<span class="pl-en">new_leaf</span>(<span class="pl-k">int</span> i) {
    <span class="pl-k">struct</span> bstnode *leaf = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> bstnode));
    leaf-&gt;item = i;
    leaf-&gt;left = <span class="pl-c1">NULL</span>;
    leaf-&gt;right = <span class="pl-c1">NULL</span>;
    <span class="pl-k">return</span> leaf;
}</pre></div>

<p>As with lists, we can write tree functions recursively or iteratively.</p>

<p>Wee need to <strong>recurse</strong> on nodes. This code emulates a functional approach, but is careful to only allocate one new (leaf) node.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> bstnode *<span class="pl-en">insert_bstnode</span>(<span class="pl-k">int</span> i, <span class="pl-k">struct</span> bstnode *node) {
    <span class="pl-k">if</span> (node == <span class="pl-c1">NULL</span>) {
        node = <span class="pl-c1">new_leaf</span>(i);
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (i &lt; node-&gt;item) {
        node-&gt;left = <span class="pl-c1">insert_bstnode</span>(i, node-&gt;left);
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (i &gt; node-&gt;item) {
        node-&gt;right = <span class="pl-c1">insert_bstnode</span>(i, node-&gt;right);
    } <span class="pl-c">// else do nothing, as item already exists.</span>
    <span class="pl-k">return</span> node;
}

<span class="pl-k">void</span> <span class="pl-en">bst_insert</span>(<span class="pl-k">int</span> i, <span class="pl-k">struct</span> bst *t) {
    t-&gt;root = <span class="pl-c1">insert_bstnode</span>(i, t-&gt;root);
}</pre></div>

<p>The iterative version is similar to the linked list approach.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">bst_insert</span>(<span class="pl-k">int</span> i, <span class="pl-k">struct</span> bst *t) {
    <span class="pl-k">struct</span> bstnode *curnode = t-&gt;root;
    <span class="pl-k">struct</span> bstnode *prevnode = <span class="pl-c1">NULL</span>;
    <span class="pl-k">while</span> (curnode) {
        <span class="pl-k">if</span> (curnode-&gt;item == i) <span class="pl-k">return</span>;
        prevnode = curnode;
        <span class="pl-k">if</span> (i &lt; curnode-&gt;item) {
            curnode = curnode-&gt;left;
        } <span class="pl-k">else</span> {
            curnode = curnode-&gt;right;
        }
    }
    <span class="pl-k">if</span> (prevnode == <span class="pl-c1">NULL</span>) { <span class="pl-c">// tree was empty</span>
        t-&gt;root = <span class="pl-c1">new_leaf</span>(i);
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (i &lt; prevnode-&gt;item) {
        prevnode-&gt;left = <span class="pl-c1">new_leaf</span>(i);
    } <span class="pl-k">else</span> {
        prevnode-&gt;right = <span class="pl-c1">new_leaf</span>(i);
    }
}</pre></div>

<h4>
<a id="user-content-trees-and-efficiency" class="anchor" href="#trees-and-efficiency" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Trees and efficiency</h4>

<p>What is the efficiency of <code>bst_insert</code>?</p>

<p>The worst case is when the tree is <strong>unbalanced</strong>, and every node in the tree must be visited.</p>

<p><a href="https://camo.githubusercontent.com/83c7f34388bf34cd6e69e13231c667def095c670/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706735342e504e47" target="_blank"><img src="https://camo.githubusercontent.com/83c7f34388bf34cd6e69e13231c667def095c670/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706735342e504e47" alt="unbalanced" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg54.PNG" style="max-width:100%;"></a></p>

<p>In this example, the running time of <code>bst_insert</code> is $O(n)$, where $n$ is the number of nodes in the tree.</p>

<p>The running time of <code>bst_insert</code> is $O(h)$: it depends more on the height of the tree (h) than the size of the tree (n),</p>

<p>The definition of a <strong>balanced tree</strong> is a tree where the height (h) is $O(\log n)$.</p>

<p>Conversely, an unbalanced tree is a tree with a height that is not $O(\log n)$. The height of an unbalanced tree is $O(n)$.</p>

<p>Using the <code>bst_insert</code> function we provided, inserting the nodes in sorted order creates an unbalanced tree.</p>

<p>With a <strong>balanced</strong> tree, the running time of standard tree functions (e.g. <code>insert</code>, <code>remove</code>, <code>search</code>) are all $O(\log n)$.</p>

<p>With an <strong>unbalanced</strong> tree, the running time of each function is $O(h)$.</p>

<p>A <strong>self-balancing tree</strong> "re-arranges" the nodes to ensure that tree is always balanced.</p>

<p>With a good self-balancing implementation, all standard tree functions preserve the balance of the tree and have an $O(\log n)$ running time.</p>

<h4>
<a id="user-content-size-node-augmentation" class="anchor" href="#size-node-augmentation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Size node augmentation</h4>

<p>A popular tree <strong>node augmentation</strong> is to store in each node the size of its subtree.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> bstnode {
    <span class="pl-k">int</span> item;
    <span class="pl-k">struct</span> bstnode *left;
    <span class="pl-k">struct</span> bstnode *right;
    <span class="pl-k">int</span> size;d
};</pre></div>

<p>This augmentation allows us to retrieve the size of the tree in $O(1)$ time.</p>

<p>It also allows us to implement a <code>select</code> function in $O(h)$ time.</p>

<p><code>select(k)</code> finds the k-th smallest item in the tree.</p>

<p><a href="https://camo.githubusercontent.com/32c17e758543247affc0ffd9bb06690c13e3c7a1/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706735382e504e47" target="_blank"><img src="https://camo.githubusercontent.com/32c17e758543247affc0ffd9bb06690c13e3c7a1/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706735382e504e47" alt="size node augmentation" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg58.PNG" style="max-width:100%;"></a></p>

<p>The following code illustrate how to select the k-th item in a BST with a size node augmentation.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">select_node</span>(<span class="pl-k">int</span> k, <span class="pl-k">struct</span> bstnode *node) {
    <span class="pl-c1">assert</span>(node &amp;&amp; <span class="pl-c1">0</span> &lt;= k &amp;&amp; k &lt; node-&gt;size);
    <span class="pl-k">int</span> left_size = <span class="pl-c1">0</span>;
    <span class="pl-k">if</span> (node-&gt;left) left_size = node-&gt;left-&gt;size;
    <span class="pl-k">if</span> (k &lt; left_size) <span class="pl-k">return</span> <span class="pl-c1">select_node</span>(k, node-&gt;left);
    <span class="pl-k">if</span> (k == left_size) <span class="pl-k">return</span> node-&gt;item;
    <span class="pl-k">return</span> <span class="pl-c1">select_node</span>(k - left_size - <span class="pl-c1">1</span>, node-&gt;right);
}

<span class="pl-k">int</span> <span class="pl-en">bst_select</span>(<span class="pl-k">int</span> k, <span class="pl-k">struct</span> bst *t) {
    <span class="pl-k">return</span> <span class="pl-c1">select_node</span>(k, t-&gt;root);
}</pre></div>

<p><code>select(0, t)</code> finds the smallest item in the tree.</p>

<h4>
<a id="user-content-array-based-trees" class="anchor" href="#array-based-trees" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Array-based trees</h4>

<p>For some types of trees, it is possible to use an <strong>array</strong> to store a tree.</p>

<ul>
<li>  the root is stored at <code>a[0]</code>
</li>
<li>  for the node at <code>a[i]</code>, its <code>left</code> is stored at <code>a[2*i+1]</code>
</li>
<li>  its <code>right</code> is stored at <code>a[2*i+2]</code>
</li>
<li>  its <code>parent</code> is stored at <code>a[(i-1)/2]</code>
</li>
<li>  a special <em>sentinel value</em> can be used to indicate an empty node</li>
<li>  a tree of height $h$ requires an array of size $2^h-1$
(a dynamic array can be realloc'd as the tree height grows)</li>
</ul>

<p><a href="https://camo.githubusercontent.com/f1ff1f5bdc0071b30b1efde4edac84af6c552e2d/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706736312e504e47" target="_blank"><img src="https://camo.githubusercontent.com/f1ff1f5bdc0071b30b1efde4edac84af6c552e2d/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706736312e504e47" alt="array based tree" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg61.PNG" style="max-width:100%;"></a></p>

<blockquote>
<p>Array-based trees are often used to implement “complete trees”,
where there are no empty nodes, and every level of the tree is
filled (except the bottom).
The heap data structure (not the section of memory) is often
implemented as a complete tree in an array.
For self-balancing trees, the self-balancing (e.g., rotations) is
often more awkward in the array notation. However, arrays work
well with lazy rebalancing, where a rebalancing occurs
infrequently (i.e., when a large inbalance is detected). The tree
can be rebalanced in $O(n)$ time, typically achieving amortized
$O(log n)$ operations.</p>
</blockquote>

<h4>
<a id="user-content-dictionary-adt-revisited" class="anchor" href="#dictionary-adt-revisited" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dictionary ADT (revisited)</h4>

<p>The dictionary ADT (also called a map, associative array, or symbol
table), is a collection of <strong>pairs</strong> of <strong>keys</strong> and <strong>values</strong>. Each key is unique and has a corresponding value, but more than one key may have the same value.</p>

<p>Typical dictionary ADT operations:</p>

<ul>
<li>  <strong>look up</strong>: for a given key, retrieve the corresponding value or "not found"</li>
<li>  <strong>insert</strong>: adds a new key/value pair (or replaces the value of an existing key)</li>
<li>  <strong>remove</strong>: deletes a key and its value</li>
</ul>

<p>In the following example, we implement a Dictionary ADT using a BST data structure.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-c">// dictionary.h</span>

<span class="pl-k">struct</span> dictionary;
<span class="pl-k">struct</span> dictionary *<span class="pl-en">dict_create</span>(<span class="pl-k">void</span>);
<span class="pl-k">void</span> <span class="pl-en">dict_insert</span>(<span class="pl-k">int</span> key, <span class="pl-k">const</span> <span class="pl-k">char</span> *val, <span class="pl-k">struct</span> dictionary *d);
<span class="pl-k">const</span> <span class="pl-k">char</span> *<span class="pl-en">dict_lookup</span>(<span class="pl-k">int</span> key, <span class="pl-k">struct</span> dictionary *d);
<span class="pl-k">void</span> <span class="pl-en">dict_remove</span>(<span class="pl-k">int</span> key, <span class="pl-k">struct</span> dictionary *d);
<span class="pl-k">void</span> <span class="pl-en">dict_destroy</span>(<span class="pl-k">struct</span> dictionary *d);</pre></div>

<p>Using the same <code>bstnode</code> structure, we augment each node by adding an additional <code>value</code> field.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> bstnode {
    <span class="pl-k">int</span> item; <span class="pl-c">// key</span>
    <span class="pl-k">char</span> *value; <span class="pl-c">// additional value</span>
    <span class="pl-k">struct</span> bstnode *left;
    <span class="pl-k">struct</span> bstnode *right;
};
<span class="pl-k">struct</span> dictionary {
    <span class="pl-k">struct</span> bstnode *root;
};
<span class="pl-k">struct</span> dictionary *<span class="pl-en">dict_create</span>(<span class="pl-k">void</span>) {
    <span class="pl-k">struct</span> dictionary *d = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> dictionary));
    d-&gt;root = <span class="pl-c1">NULL</span>;
    <span class="pl-k">return</span> d;
}</pre></div>

<p>When inserting key/value pairs to the dictionary, we make a copy of the string passed by the client. When removing nodes, we also <code>free</code> the value.</p>

<p>If the client tries to insert a duplicate key, we replace the old value with the new value.</p>

<p>The following recursive implementation of the <code>insert</code> operation is nearly identical to our previous <code>bst_insert</code>. The differences are noted with comments.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> bstnode *<span class="pl-en">insert_bstnode</span>(<span class="pl-k">int</span> key, <span class="pl-k">const</span> <span class="pl-k">char</span> *val, <span class="pl-k">struct</span> bstnode *node) {
    <span class="pl-k">if</span> (node == <span class="pl-c1">NULL</span>) {
        node = <span class="pl-c1">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> bstnode));
        node-&gt;item = key;
        node-&gt;value = <span class="pl-c1">my_strdup</span>(val); <span class="pl-c">// make copy</span>
        node-&gt;left = <span class="pl-c1">NULL</span>;
        node-&gt;right = <span class="pl-c1">NULL</span>;
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (key &lt; node-&gt;item) {
        node-&gt;left = <span class="pl-c1">insert_bstnode</span>(key, val, node-&gt;left);
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (key &gt; node-&gt;item) {
        node-&gt;right = <span class="pl-c1">insert_bstnode</span>(key, val, node-&gt;right);
    } <span class="pl-k">else</span> { <span class="pl-c">// key == node-&gt;item: must replace the old value</span>
        <span class="pl-c1">free</span>(node-&gt;value);
        node-&gt;value = <span class="pl-c1">my_strdup</span>(val);
    }
    <span class="pl-k">return</span> node;
}

<span class="pl-k">void</span> <span class="pl-en">dict_insert</span>(<span class="pl-k">int</span> key, <span class="pl-k">const</span> <span class="pl-k">char</span> *val, <span class="pl-k">struct</span> dictionary *d) {
    d-&gt;root = <span class="pl-c1">insert_bstnode</span>(key, val, d-&gt;root);
}</pre></div>

<p>This implementation of the <code>lookup</code> operation will return <code>NULL</code> if unsuccessful.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">const</span> <span class="pl-k">char</span> *<span class="pl-en">dict_lookup</span>(<span class="pl-k">int</span> key, <span class="pl-k">struct</span> dictionary *d) {
    <span class="pl-k">struct</span> bstnode *curnode = d-&gt;root;
    <span class="pl-k">while</span> (curnode) {
        <span class="pl-k">if</span> (curnode-&gt;item == key) {
            <span class="pl-k">return</span> curnode-&gt;value;
        }
        <span class="pl-k">if</span> (key &lt; curnode-&gt;item) {
            curnode = curnode-&gt;left;
        } <span class="pl-k">else</span> {
            curnode = curnode-&gt;right;
        }
    }
    <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
}</pre></div>

<p>There are several different ways of removing a node from a BST.</p>

<p>We implement <code>remove</code> with the following strategy:</p>

<ul>
<li>  If the node with the key ("key node") is a leaf, we remove it.</li>
<li>  If one child of the key node is empty (<code>NULL</code>), the other child is "promoted" to replace the key node.</li>
<li>  Otherwise, we find the node with the next largest key ("next node") in the tree (i.e. the smallest key in the right subtree). We replace the key/value of the key node with the key/value of the next node, and then remove the next node from the right subtree.</li>
</ul>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">dict_remove</span>(<span class="pl-k">int</span> key, <span class="pl-k">struct</span> dictionary *d) {
    d-&gt;root = <span class="pl-c1">remove_bstnode</span>(key, d-&gt;root);
}

<span class="pl-k">struct</span> bstnode *<span class="pl-en">remove_bstnode</span>(<span class="pl-k">int</span> key, <span class="pl-k">struct</span> bstnode *node) {
    <span class="pl-c">// key did not exist:</span>
    <span class="pl-k">if</span> (node == <span class="pl-c1">NULL</span>) <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;

    <span class="pl-c">// search for the node that contains the key</span>
    <span class="pl-k">if</span> (key &lt; node-&gt;item) {
        node-&gt;left = <span class="pl-c1">remove_bstnode</span>(key, node-&gt;left);
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (key &gt; node-&gt;item) {
        node-&gt;right = <span class="pl-c1">remove_bstnode</span>(key, node-&gt;right);
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (node-&gt;left == <span class="pl-c1">NULL</span>) {
        <span class="pl-k">struct</span> bstnode *backup = node-&gt;right;
        <span class="pl-c1">free</span>(node-&gt;value);
        <span class="pl-c1">free</span>(node);
        <span class="pl-k">return</span> backup;
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (node-&gt;right == <span class="pl-c1">NULL</span>) {
        <span class="pl-k">struct</span> bstnode *backup = node-&gt;left;
        <span class="pl-c1">free</span>(node-&gt;value);
        <span class="pl-c1">free</span>(node);
        <span class="pl-k">return</span> backup;
    } <span class="pl-k">else</span> {
        <span class="pl-c">// find the next largest key</span>
        <span class="pl-k">struct</span> bstnode *next = node-&gt;right;
        <span class="pl-k">while</span> (next-&gt;left) {
            next = next-&gt;left;
        }

        <span class="pl-c">// remove the old value</span>
        <span class="pl-c1">free</span>(node-&gt;value);

        <span class="pl-c">// replace the key/value of this node</span>
        node-&gt;item = next-&gt;item;
        node-&gt;value = <span class="pl-c1">my_strdup</span>(next-&gt;value);

        <span class="pl-c">// remove the next largest key</span>
        node-&gt;right = <span class="pl-c1">remove_bstnode</span>(next-&gt;item, node-&gt;right);
    }

    <span class="pl-k">return</span> node;
}</pre></div>

<p>Finally, the recursive <code>destroy</code> operation frees the children and the (string) value before itself.</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span> <span class="pl-en">free_bstnode</span>(<span class="pl-k">struct</span> bstnode *node) {
    <span class="pl-k">if</span> (node) {
        <span class="pl-c1">free_bstnode</span>(node-&gt;left);
        <span class="pl-c1">free_bstnode</span>(node-&gt;right);
        <span class="pl-c1">free</span>(node-&gt;value);
        <span class="pl-c1">free</span>(node);
    }
}
<span class="pl-k">void</span> <span class="pl-en">dict_destroy</span>(<span class="pl-k">struct</span> dictionary *d) {
    <span class="pl-c1">free_bstnode</span>(d-&gt;root);
    <span class="pl-c1">free</span>(d);
}</pre></div>

<h4>
<a id="user-content-graphs" class="anchor" href="#graphs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Graphs</h4>

<p>Linked lists and trees can be thought of as “special cases” of a
<strong>graph</strong> data structure.</p>

<p><a href="https://camo.githubusercontent.com/ef0a1fb0f4fc640ebc06092482bf8cf9d806c006/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706737342e504e47" target="_blank"><img src="https://camo.githubusercontent.com/ef0a1fb0f4fc640ebc06092482bf8cf9d806c006/687474703a2f2f746f6e796c692e746b2f6e6f7465732f63733133362f7365633131706737342e504e47" alt="graphs" data-canonical-src="http://tonyli.tk/notes/cs136/sec11pg74.PNG" style="max-width:100%;"></a></p>

<p>Graphs link <strong>nodes</strong> with <strong>edges</strong>. Graphs may be undirected (i) or
directed (ii), allow cycles (ii) or be acyclic (iii), and have labeled
edges (iv) or unlabeled edges (iii).</p>

<h4>
<a id="user-content-goals-of-this-section" class="anchor" href="#goals-of-this-section" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Goals of this section</h4>

<p>At the end of this section, you should be able to:</p>

<ul>
<li>  use the new linked list and tree terminology introduced</li>
<li>  use linked lists and trees with a recursive or iterative approach</li>
<li>  use wrapper structures and node augmentations to improve
efficiency</li>
<li>  explain why an unbalanced tree can affect the efficiency of tree</li>
</ul>
</article></body></html>