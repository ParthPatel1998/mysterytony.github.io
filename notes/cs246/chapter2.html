<!DOCTYPE html><html><head><meta charset="utf-8"><style>/* {
}

body {
    padding-left: 10px;
    padding-right: 10px;
    margin-right: auto;
    margin-left: auto;
}

body .markdown-body {
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 3px;
    word-wrap: break-word;
}

pre {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body {
    -webkit-text-size-adjust: 100%;
    text-size-adjust: 100%;
    color: #333;
    font-family: "Segoe UI", Frutiger, "Frutiger Linotype", "Dejavu Sans", "Helvetica Neue", Arial, sans-serif;
    font-size: 20px;
    line-height: 1.2;
    word-wrap: break-word;
}

.markdown-body a {
    background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
    outline: 0;
}

.markdown-body strong {
    font-weight: bold;
    color: #BC0000;
}

.markdown-body h1 {
    margin: 0.67em 0;
}

.markdown-body img {
    border: 0;
    box-shadow: 5px 5px 5px #D6D6D6;
}

.markdown-body hr {
    box-sizing: content-box;
    height: 0;
}

.markdown-body pre {
    overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
    font-family: monospace, monospace;
    font-size: 1em;
}

.markdown-body input {
    color: inherit;
    font: inherit;
    margin: 0;
}

.markdown-body html input[disabled] {
    cursor: default;
}

.markdown-body input {
    line-height: normal;
}

.markdown-body input[type="checkbox"] {
    box-sizing: border-box;
    padding: 0;
}

.markdown-body table {
    border-collapse: collapse;
    border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
    padding: 0;
}

.markdown-body input {
    font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

.markdown-body a {
    color: #4078c0;
    text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:active {
    text-decoration: underline;
}

.markdown-body hr {
    height: 0;
    margin: 15px 0;
    overflow: hidden;
    background: transparent;
    border: 0;
    border-bottom: 1px solid #ddd;
}

.markdown-body hr:before {
    display: table;
    content: "";
}

.markdown-body hr:after {
    display: table;
    clear: both;
    content: "";
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
    margin-top: 15px;
    margin-bottom: 15px;
    line-height: 1.1;
    color: #011380;
}

.markdown-body h1 {
    font-size: 30px;
}

.markdown-body h2 {
    font-size: 21px;
}

.markdown-body h3 {
    font-size: 16px;
}

.markdown-body h4 {
    font-size: 14px;
}

.markdown-body h5 {
    font-size: 12px;
}

.markdown-body h6 {
    font-size: 11px;
}

.markdown-body blockquote {
    margin: 0;
}

.markdown-body ul,
.markdown-body ol {
    padding: 0;
    margin-top: 0;
    margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
    list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
    list-style-type: lower-alpha;
}

.markdown-body dd {
    margin-left: 0;
}

.markdown-body code {
    font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 12px;
}

.markdown-body pre {
    margin-top: 0;
    margin-bottom: 0;
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body .select::-ms-expand {
    opacity: 0;
}

.markdown-body .octicon {
    font: normal normal normal 16px/1 octicons-anchor;
    display: inline-block;
    text-decoration: none;
    text-rendering: auto;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

.markdown-body .octicon-link:before {
    content: '\f05c';
}

.markdown-body:before {
    display: table;
    content: "";
}

.markdown-body:after {
    display: table;
    clear: both;
    content: "";
}

.markdown-body>*:first-child {
    margin-top: 0 !important;
}

.markdown-body>*:last-child {
    margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
    color: inherit;
    text-decoration: none;
}

.markdown-body .anchor {
    display: inline-block;
    padding-right: 2px;
    margin-left: -18px;
}

.markdown-body .anchor:focus {
    outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
    margin-top: 1em;
    margin-bottom: 16px;
    font-weight: bold;
    line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
    color: #000;
    vertical-align: middle;
    visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
    text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
    visibility: visible;
}

.markdown-body h1 {

    padding-bottom: 0.3em;
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}

.markdown-body h1 .anchor {
    line-height: 1;
}

.markdown-body h2 {

  border-top: 4px solid #4B0000;
  background-color: #BFADAD;
    padding: 5px;
    font-size: 1.75em;
    line-height: 1.225;
}

.markdown-body h2 .anchor {
    line-height: 1;
}

.markdown-body h3 {
    font-size: 1.5em;
    line-height: 1.43;
}

.markdown-body h3 .anchor {
    line-height: 1.2;
}

.markdown-body h4 {
    font-size: 1.25em;
}

.markdown-body h4 .anchor {
    line-height: 1.2;
}

.markdown-body h5 {
    font-size: 1em;
}

.markdown-body h5 .anchor {
    line-height: 1.1;
}

.markdown-body h6 {
    font-size: 1em;
    color: #777;
}

.markdown-body h6 .anchor {
    line-height: 1.1;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
    margin-top: 0;
    margin-bottom: 16px;
}

.markdown-body hr {
    height: 4px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
    padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
    margin-top: 0;
    margin-bottom: 0;
}

.markdown-body li>p {
    margin-top: 16px;
}

.markdown-body dl {
    padding: 0;
}

.markdown-body dl dt {
    padding: 0;
    margin-top: 16px;
    font-size: 1em;
    font-style: italic;
    font-weight: bold;
}

.markdown-body dl dd {
    padding: 0 16px;
    margin-bottom: 16px;
}

.markdown-body blockquote {
    padding: 0 15px;
    color: #012A58;
    border-left: 4px solid #68AFFF;
    background-color: #BAD9FB
}

.markdown-body blockquote>:first-child {
    margin-top: 0;
}

.markdown-body blockquote>:last-child {
    margin-bottom: 0;
}

.markdown-body table {
    display: block;
    width: 100%;
    overflow: auto;
    word-break: normal;
    word-break: keep-all;
}

.markdown-body table th {
    font-weight: bold;
    color: #012C45;
}

.markdown-body table th,
.markdown-body table td {
    padding: 6px 13px;
    border: 1px solid #4283A9;
}

.markdown-body table tr {
    background-color: #fff;
    border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
    background-color: #D1EEFF;
}

.markdown-body img {
    max-width: 100%;
    box-sizing: content-box;
    background-color: #fff;
}

.markdown-body code {
    padding: 0;
    padding-top: 0.2em;
    padding-bottom: 0.2em;
    margin: 0;
    font-size: 85%;
    background-color: #F1F1F1;
}

.markdown-body code:before,
.markdown-body code:after {
    letter-spacing: -0.2em;
    content: "\00a0";
}

.markdown-body pre>code {
    padding: 0;
    margin: 0;
    font-size: 100%;
    word-break: normal;
    white-space: pre;
    background: transparent;
    border: 0;
}

.markdown-body .highlight {
    margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
    background-color: #FDFFCB;
    border-left: 4px solid #8E9402;
}

.markdown-body .highlight pre {
    margin-bottom: 0;
    word-break: normal;
}

.markdown-body pre {
    word-wrap: normal;
}

.markdown-body pre code {
    display: inline;
    max-width: initial;
    padding: 0;
    margin: 0;
    overflow: initial;
    line-height: inherit;
    word-wrap: normal;
    background-color: transparent;
    border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
    content: normal;
}

.markdown-body kbd {
    display: inline-block;
    padding: 3px 5px;
    font-size: 11px;
    line-height: 10px;
    color: #555;
    vertical-align: middle;
    background-color: #fcfcfc;
    border: solid 1px #ccc;
    border-bottom-color: #bbb;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .pl-c {
    color: #009B00;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
    color: #0086b3;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
    color: #795da3;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
    color: #333;
}

.markdown-body .pl-ent {
    color: #63a35c;
}

.markdown-body .pl-k {
    color: #a71d5d;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
    color: #183691;
}

.markdown-body .pl-v {
    color: #ed6a43;
}

.markdown-body .pl-id {
    color: #b52a1d;
}

.markdown-body .pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.markdown-body .pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.markdown-body .pl-ml {
    color: #693a17;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.markdown-body .pl-mq {
    color: #008080;
}

.markdown-body .pl-mi {
    color: #333;
    font-style: italic;
}

.markdown-body .pl-mb {
    color: #333;
    font-weight: bold;
}

.markdown-body .pl-md {
    background-color: #ffecec;
    color: #bd2c00;
}

.markdown-body .pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.markdown-body .pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.markdown-body .pl-mo {
    color: #1d3e81;
}

.markdown-body kbd {
    display: inline-block;
    padding: 3px 5px;
    font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
    line-height: 10px;
    color: #555;
    vertical-align: middle;
    background-color: #fcfcfc;
    border: solid 1px #ccc;
    border-bottom-color: #bbb;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .plan-price-unit {
    color: #767676;
    font-weight: normal;
}

.markdown-body .task-list-item {
    list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
    margin-top: 3px;
}

.markdown-body .task-list-item input {
    margin: 0 0.35em 0.25em -1.6em;
    vertical-align: middle;
}

.markdown-body .plan-choice {
    padding: 15px;
    padding-left: 40px;
    display: block;
    border: 1px solid #e0e0e0;
    position: relative;
    font-weight: normal;
    background-color: #fafafa;
}

.markdown-body .plan-choice.open {
    background-color: #fff;
}

.markdown-body .plan-choice.open .plan-choice-seat-breakdown {
    display: block;
}

.markdown-body .plan-choice-free {
    border-radius: 3px 3px 0 0;
}

.markdown-body .plan-choice-paid {
    border-radius: 0 0 3px 3px;
    border-top: 0;
    margin-bottom: 20px;
}

.markdown-body .plan-choice-radio {
    position: absolute;
    left: 15px;
    top: 18px;
}

.markdown-body .plan-choice-exp {
    color: #999;
    font-size: 12px;
    margin-top: 5px;
}

.markdown-body .plan-choice-seat-breakdown {
    margin-top: 10px;
    display: none;
}

.markdown-body:checked+.radio-label {
    z-index: 1;
    position: relative;
    border-color: #4078c0;
    }*/


/*.MathJax_Display {
    color: #4B0158;
    padding-top: 5px;
    padding-bottom: 5px;
    background-color: #FEFAFF
    }*/


/* Extracted and interpreted from adcstyle.css and frameset_styles.css */


/* body */

body {
    margin: 20px auto;
    width: 80%;
    background-color: #fff;
    color: #000;
    /*font: 20px "Myriad Pro", "Lucida Grande", Lucida, Verdana, sans-serif;*/
    font: 20px Georgia, serif;
    line-height: 1.3;
}

p {
    text-indent: 50px;
}

/* links */

a:link {
    color: #00f;
    text-decoration: none;
}

a:visited {
    color: #00a;
    text-decoration: none;
}

a:hover {
    color: #f60;
    text-decoration: underline;
}

a:active {
    color: #f60;
    text-decoration: underline;
}


/* html tags */


/*  Work around IE/Win code size bug - courtesy Jesper, waffle.wootest.net  */


/** html code {
    font-size: 101%;
}

* html pre {
    font-size: 101%;
    }*/


/* code */

pre,
code {
    font-size: 20px;
    font-family: monaco, courier, consolas, monospace;
}

code {
    background-color: #EFEFEF;
    padding: 3px;
}

pre {
    margin-top: 5px;
    margin-bottom: 10px;
    border: 1px solid #c7cfd5;
    background: #f1f5f9;
    margin: 20px 0;
    padding: 8px;
    text-align: left;
    border-radius: 3px;
    border-left-width: 3px;
    border-left-color: #94B0F7;
    white-space: pre-wrap;
    /* CSS3 */
    white-space: -moz-pre-wrap;
    /* Firefox */
    white-space: -pre-wrap;
    /* Opera <7 */
    white-space: -o-pre-wrap;
    /* Opera 7 */
    word-wrap: break-word;
    /* IE */
}

blockquote {
    margin-top: 5px;
    margin-bottom: 10px;
    border: 1px solid #D5D5C7;
    background: #F9F9F1;
    margin: 20px 0;
    padding: 8px;
    text-align: left;
    border-radius: 3px;
    border-left-width: 3px;
    border-left-color: #E6E770;
    white-space: pre-wrap;
    /* CSS3 */
    white-space: -moz-pre-wrap;
    /* Firefox */
    white-space: -pre-wrap;
    /* Opera <7 */
    white-space: -o-pre-wrap;
    /* Opera 7 */
    word-wrap: break-word;
    /* IE */
}

hr {
    color: #919699;
    size: 1;
    width: 100%;
    noshade: "noshade"
}


/* headers */

h1,
h2,
h3,
h4,
h5,
h6 {
    /*font-family: "Myriad Pro", "Lucida Grande", Lucida, Verdana, sans-serif;*/
    font-weight: bold;
}

h1 {
    margin-top: 1em;
    margin-bottom: 25px;
    color: #000;
    font-weight: bold;
    font-size: 35px;
    text-align: center;
}

h2 {
    margin-top: 2.5em;
    font-size: 30px;
    color: #000;
    padding-bottom: 2px;
    border-bottom: 1px solid #919699;
    border-left-style: solid;
    border-left-width: 15px;
    border-left-color: #000565;
    padding-left: 5px;
}

h3 {
    margin-top: 2em;
    margin-bottom: .5em;
    font-size: 25px;
    color: #000;
}

h4 {
    /*margin-top: 2em;*/
    /*margin-top: 5px;*/
    margin-bottom: .5em;
    font-size: 23px;
    color: #000;
}

h5 {
    margin-top: 5px;
    margin-bottom: .5em;
    padding: 0;
    font-size: 21px;
    color: #000;
}

h6 {
    margin-top: 20px;
    margin-bottom: .5em;
    padding: 0;
    font-size: 11px;
    color: #000;
}

p {
    margin-top: 0px;
    margin-bottom: 10px;
}


/* lists */

ul {
    list-style: square outside;
    margin: 0 0 0 30px;
    padding: 0 0 12px 6px;
}

li {
    margin-top: 7px;
}

ol {
    list-style-type: decimal;
    list-style-position: outside;
    margin: 0 0 0 30px;
    padding: 0 0 12px 6px;
}

ol ol {
    list-style-type: lower-alpha;
    list-style-position: outside;
    margin: 7px 0 0 30px;
    padding: 0 0 0 10px;
}

ul ul {
    margin-left: 40px;
    padding: 0 0 0 6px;
}

li>p {
    display: inline
}

li>p+p {
    display: block
}

li>a+p {
    display: block
}


/* table */

table {
    border-top: 1px solid #919699;
    border-left: 1px solid #919699;
    border-spacing: 0;
}

table th {
    padding: 4px 8px 4px 8px;
    background: #E2E2E2;
    /*font-size: 12px;*/
    border-bottom: 1px solid #919699;
    border-right: 1px solid #919699;
}

table th p {
    font-weight: bold;
    margin-bottom: 0px;
}

table td {
    padding: 8px;
    /*font-size: 12px;*/
    vertical-align: top;
    border-bottom: 1px solid #919699;
    border-right: 1px solid #919699;
}

table td p {
    margin-bottom: 0px;
}

table td p + p {
    margin-top: 5px;
}

table td p + p + p {
    margin-top: 5px;
}


/* forms */

form {
    margin: 0;
}

button {
    margin: 3px 0 10px 0;
}

input {
    vertical-align: middle;
    padding: 0;
    margin: 0 0 5px 0;
}

select {
    vertical-align: middle;
    padding: 0;
    margin: 0 0 3px 0;
}

textarea {
    margin: 0 0 10px 0;
    width: 100%;
}

img {
    max-height: 400px; /* you can use % */
    max-width: 400px;
    height: auto;
    width: auto;
    border-style: solid;
    border-color: #B4B4B4;
    border-width: 2px;
}

.markdown-body .pl-c {
    color: #009B00;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
    color: #0086b3;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
    color: #795da3;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
    color: #333;
}

.markdown-body .pl-ent {
    color: #63a35c;
}

.markdown-body .pl-k {
    color: #a71d5d;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
    color: #183691;
}

.markdown-body .pl-v {
    color: #ed6a43;
}

.markdown-body .pl-id {
    color: #b52a1d;
}

.markdown-body .pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.markdown-body .pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.markdown-body .pl-ml {
    color: #693a17;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.markdown-body .pl-mq {
    color: #008080;
}

.markdown-body .pl-mi {
    color: #333;
    font-style: italic;
}

.markdown-body .pl-mb {
    color: #333;
    font-weight: bold;
}

.markdown-body .pl-md {
    background-color: #ffecec;
    color: #bd2c00;
}

.markdown-body .pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.markdown-body .pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.markdown-body .pl-mo {
    color: #1d3e81;
}
</style><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: false
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false
});
</script>
<title>chapter2</title></head><body><article class="markdown-body"><h1>
<a id="user-content-c" class="anchor" href="#c" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>C++</h1>

<h2>
<a id="user-content-21-design" class="anchor" href="#21-design" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.1 Design</h2>

<ul>
<li>  <strong>Design</strong> is a plan for solving a problem, but leads to multiple solutions</li>
<li>  Need the ability to compare designs</li>
<li>  2 measures: coupling and cohesion</li>
<li>  <strong>Coupling</strong> is degree of interdependence <strong>among</strong> programming modules</li>
<li>  Aim is to achieve lowest coupling or highest independence (i.e., each module can stand alone or close to it)</li>
<li>  Module is read and understood as a unit =&gt; changes do not effect other modules and can be isolated for testing purpose (like stereo components)</li>
<li>  <strong>Cohesion</strong> is degree of element association <strong>within</strong> a module (focus)</li>
<li>  Elements can be a statement, group of statements, or calls to other modules</li>
<li>  Alternate names for cohesion: binding, functionality, modular strength</li>
<li>  Highly cohesive module has strongly and genuinely related elements</li>
<li>  <strong>Low cohesion</strong> (module elements NOT related) =&gt; <strong>loose coupling</strong>
</li>
<li>  <strong>High cohesion</strong> (module elements related) =&gt; tight coupling</li>
</ul>

<h2>
<a id="user-content-22-cc-composition" class="anchor" href="#22-cc-composition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.2 C/C++ Composition</h2>

<ul>
<li>  C++ is composed of 3 languages:

<ol>
<li> <strong>Before</strong> compilation, preprocessor language (cpp) modifies (text-edits) the program</li>
<li> <strong>During</strong> compilation, template (generic) language adds new types and routines</li>
<li> <strong>During</strong> compilation,

<ul>
<li>  C programming language specifying basic declaration and control flow.</li>
<li>  C++ programming language specifying advanced declarations and control flow</li>
</ul>
</li>
</ol>
</li>
<li>  A programmer uses the three programming languages as follows:
user edits -&gt; <strong>preprocessor edits</strong> -&gt; <strong>templates expand</strong> -&gt; <strong>compilation</strong> (-&gt; linking/loading -&gt; execution)</li>
<li>  C is composed of language 1 &amp; 3</li>
<li>  The compiler interface controls all of these steps
C/C++ header files &amp; C/C++ source files -&gt; (preprocessor) cpp -&gt; preprocessed source code -&gt; (translator) cc1plus -&gt; assembly code -&gt; (assembler) as -&gt; object code -&gt; other object-code file and libraries id (liner) -&gt; ./a.out &amp; object</li>
</ul>

<h2>
<a id="user-content-23-first-program" class="anchor" href="#23-first-program" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.3 First Program</h2>

<p>Java:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">import</span> <span class="pl-smi">java.lang.*</span>; <span class="pl-c">// implicit</span>
<span class="pl-k">class</span> <span class="pl-en">Hello</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span>
    <span class="pl-k">void</span> <span class="pl-en">main</span>( <span class="pl-k">String</span>[ ] <span class="pl-v">args</span> ) {
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>Hello!<span class="pl-pds">"</span></span>);
        <span class="pl-smi">System</span><span class="pl-k">.</span>exit( <span class="pl-c1">0</span> );
    }
}</pre></div>

<p>C:</p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    <span class="pl-c1">printf</span>( <span class="pl-s"><span class="pl-pds">"</span>Hello!<span class="pl-cce">\n</span><span class="pl-pds">"</span></span> );
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<p>C++:</p>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span> <span class="pl-c">// access to output</span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span> <span class="pl-c">// direct naming</span>
<span class="pl-k">int</span> <span class="pl-en">main</span>() { <span class="pl-c">// program starts here</span>
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Hello!<span class="pl-pds">"</span></span> &lt;&lt; endl;
    <span class="pl-k">return</span> <span class="pl-c1">0</span>; <span class="pl-c">// return 0 to shell, optional</span>
}</pre></div>

<ul>
<li>  <code>#include &lt;iostream&gt;</code> copies (imports) basic I/O descriptions (no equivalent in Java)</li>
<li>  <code>using namespace std</code> allows imported I/O names to accessed directly (otherwise qualification is necessary)</li>
<li>  <code>cout&lt;&lt;"Hello!"&lt;&lt;endl</code> prints "Hello!" to standard output, called <code>cout</code> (<code>System.out</code> in Java, <code>stdout</code> in C)</li>
<li>  <code>endl</code> starts a newline after "Hello!" (<code>println</code> in Java, <code>\n</code> in C)</li>
<li>  Routine <code>exit</code> (Java <code>System.exit</code>) terminates a program at any location and returns a code to the shell, e.g., <code>exit(0)</code> (<code>#include&lt;cstdlib&gt;</code>)

<ul>
<li>  Literals <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> indicate successful or unsuccessful termination results.</li>
<li>  e.g., <code>return EXIT_SUCCESS</code> or <code>exit(EXIT_FAILURE)</code>
</li>
</ul>
</li>
<li>  C program-file use suffix <code>.c</code>; C++ program-file use suffixes <code>.C/.cpp/.cc</code>
</li>
<li>  Compile with <code>g++</code> command:</li>
</ul>

<div class="highlight highlight-source-shell"><pre>$ g++ -Wall -g -std=c++11 -o firstprog firstprog.cc <span class="pl-c"># compile, create "a.out"</span>
$ ./firstprog</pre></div>

<ul>
<li>  <code>-W</code>kind generate warning message for this "kind" of situation

<ul>
<li>  <code>-Wall</code> print all warning messages</li>
<li>  <code>-Werror</code> make warnings into errors so program does not compile</li>
</ul>
</li>
<li>  <code>-g</code> add symbol-table information to object file for debugging</li>
<li>  <code>-std=c++11</code> allow new C++ 11 extensions</li>
<li>  <code>-o</code> file containing the executable (<code>a.out</code> default)</li>
<li>  create shell alias for <code>g++</code> use options <code>g++ -Wall -g -std=c++11</code>
</li>
</ul>

<h2>
<a id="user-content-24-comment" class="anchor" href="#24-comment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.4 Comment</h2>

<ul>
<li>  Comment may appear where whitespace (space, table, newline) is allowed</li>
<li>  <code>/*...*/</code> comment cannot be nested</li>
<li>  Be extremely careful in using this comment to elide/comment-out code</li>
</ul>

<h2>
<a id="user-content-25-declaration" class="anchor" href="#25-declaration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.5 Declaration</h2>

<ul>
<li>  A declaration introduces names or redeclares names from previous declarations.</li>
</ul>

<h3>
<a id="user-content-251-basic-types" class="anchor" href="#251-basic-types" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.5.1 Basic Types</h3>

<table>
<thead>
<tr>
<th>Java</th>
<th>C/C++</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>char / wchar_t</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>char / wchar_t</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>int</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>float</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>double</code></td>
</tr>
</tbody>
</table>

<ul>
<li>  C/C++ treat <code>char / wchar_t</code> as character and integral type.</li>
<li>  Java types <code>short</code> and <code>long</code> are created using type qualifiers.</li>
</ul>

<h3>
<a id="user-content-252-variable-declaration" class="anchor" href="#252-variable-declaration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.5.2 Variable Declaration</h3>

<ul>
<li>  C/C++ declaration: type followed by list of identifiers, except label with an implicit type (same in Java)</li>
</ul>

<table>
<thead>
<tr>
<th>Java/C/C++</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char a, b, c, d;</code></td>
</tr>
<tr>
<td><code>int i, j, k;</code></td>
</tr>
<tr>
<td><code>double x, y, z;</code></td>
</tr>
</tbody>
</table>

<ul>
<li>  Declarations may have an initializing assignment:</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">int</span> i = <span class="pl-c1">3</span>; <span class="pl-k">int</span> i = <span class="pl-c1">3</span>, j = i, k = f( j );
<span class="pl-k">int</span> j = <span class="pl-c1">4</span> + i;
<span class="pl-k">int</span> k = f( j );</pre></div>

<ul>
<li>  C restricts initializer elements to be constant for global declarations.</li>
</ul>

<h3>
<a id="user-content-253-type-qualifier" class="anchor" href="#253-type-qualifier" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.5.3 Type Qualifier</h3>

<ul>
<li>  Other integral types are composed with type qualifiers modifying integral types <code>char</code> and <code>int</code>
</li>
<li>  C/C++ provide size (<code>short</code>, <code>long</code>) and signed-ness (<code>signed</code> =&gt; positive/negative, <code>unsigned</code> =&gt; positive only) qualifiers</li>
<li>  <code>int</code> provides <strong>relative</strong> machine-specific types: usually <code>int</code> $\geq$ 4 bytes for 32/64-bit computer, <code>long</code> $\geq$ <code>int</code>, <code>long long</code> $\geq$ <code>long</code>
</li>
<li>  <code>#include &lt;climits&gt;</code> specifies names for lower/upper bounds of a type's range of value for a machine</li>
<li>  C/C++ provide two basic real-floating types <code>float</code> and <code>double</code>, and real-floating type generated with type qualifier.</li>
<li>  <code>#include &lt;cfloat&gt;</code> specifies names for precision and magnitude of real-floating values.</li>
</ul>

<h3>
<a id="user-content-254-literals" class="anchor" href="#254-literals" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.5.4 Literals</h3>

<ul>
<li>  Variables contain values; values have <strong>constant</strong> (C) or <strong>literal</strong> (C++) meaning.</li>
<li>  C/C++ and Java share almost all the same literals for the basic types.</li>
</ul>

<table>
<thead>
<tr>
<th>Type</th>
<th>Literals</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td><code>false, true</code></td>
</tr>
<tr>
<td>character</td>
<td><code>'a' 'b' 'c'</code></td>
</tr>
<tr>
<td>string</td>
<td><code>"abc" "a b c"</code></td>
</tr>
<tr>
<td>integral</td>
<td><code>123 -456 0133 0xfe</code></td>
</tr>
<tr>
<td>real-floating</td>
<td><code>.1 1. -1. 0.52 -6.6e-2</code></td>
</tr>
</tbody>
</table>

<ul>
<li>  Use the right literal for a variable's type:</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">bool</span> b = <span class="pl-c1">true</span>; <span class="pl-c">// not 1</span>
<span class="pl-k">int</span> i = <span class="pl-c1">1</span>; <span class="pl-c">// not 1.0</span>
<span class="pl-k">double</span> d = <span class="pl-c1">1.0</span> <span class="pl-c">// not 1</span>
<span class="pl-k">char</span> c = ’a’; <span class="pl-c">// not 97</span>
<span class="pl-k">const</span> <span class="pl-k">char</span> *cs = <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>; <span class="pl-c">// not ’a’</span></pre></div>

<ul>
<li>  Literals are <strong>undesignated</strong>, compiler chooses smallest type, or <strong>designated</strong>, programmer chooses type with suffixes: <code>L/l</code> =&gt; <code>long</code>, <code>LL/ll</code> =&gt; <code>long long</code>, <code>U/u</code> =&gt; unsigned, and <code>F/f</code> =&gt; <code>float</code>
</li>
</ul>

<div class="highlight highlight-source-c++"><pre>-<span class="pl-c1">3</span> <span class="pl-c">// undesignated, int</span>
-<span class="pl-c1">3L</span> <span class="pl-c">// designated, long int</span>
<span class="pl-c1">1000000000000000000</span> <span class="pl-c">// undesignated, long long int (why?)</span>
<span class="pl-c1">1000000000000000000LL</span> <span class="pl-c">// designated, long long int</span>
<span class="pl-c1">4U</span> <span class="pl-c">// designated, unsigned int</span>
<span class="pl-c1">100000000000000000ULL</span> <span class="pl-c">// designated, unsigned long long int</span>
<span class="pl-c1">3.5E3</span> <span class="pl-c">// undesignated, double</span>
<span class="pl-c1">3</span>.5E3F <span class="pl-c">// designated, float</span></pre></div>

<ul>
<li>  Juxtaposed string literals are concatenated</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span> <span class="pl-c">// divide literal for readability</span>
<span class="pl-s"><span class="pl-pds">"</span>Doe<span class="pl-pds">"</span></span>; <span class="pl-c">// even over multiple lines</span>
<span class="pl-s"><span class="pl-pds">"</span>JohnDoe<span class="pl-pds">"</span></span>;</pre></div>

<ul>
<li>  Every string literal is implicitly terminated with a character <code>\0</code> (<strong>sentinel</strong>)

<ul>
<li>  <code>"abc"</code> is 4 characters: <code>'a' 'b' 'c' '\0'</code> which occupies 4 bytes.</li>
<li>  String cannot contain a character with the value <code>'\0'</code>
</li>
<li>  Computing string length requires <code>O(N)</code> search for <code>'\0'</code>
</li>
</ul>
</li>
<li>  Escape sequence provides quoting of special characters in a character/string literal using a backslash <code>\</code>
</li>
</ul>

<table>
<thead>
<tr>
<th>escape</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>'\\'</code></td>
<td>backslash</td>
</tr>
<tr>
<td><code>'\''</code></td>
<td>single quote</td>
</tr>
<tr>
<td><code>'\"'</code></td>
<td>double quote</td>
</tr>
<tr>
<td><code>'\t' '\n'</code></td>
<td>tab, new line</td>
</tr>
<tr>
<td><code>'\0'</code></td>
<td>string termination character</td>
</tr>
</tbody>
</table>

<ul>
<li>  C/C++ provides user literals (write-once/read-only) with type qualifier <code>const</code>
</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">const</span> <span class="pl-k">char</span> Initial = <span class="pl-s"><span class="pl-pds">'</span>D<span class="pl-pds">'</span></span>;
<span class="pl-k">const</span> <span class="pl-k">short</span> <span class="pl-k">int</span> <span class="pl-c1">Size</span> = <span class="pl-c1">3</span>, SupSize = <span class="pl-c1">Size</span> + <span class="pl-c1">7</span>;
<span class="pl-k">const</span> <span class="pl-k">double</span> PI = <span class="pl-c1">3.14159</span>;</pre></div>

<ul>
<li>  C/C++ <code>const</code> variable <strong>must</strong> be assigned a value at declaration, the value can be the result of a expression.</li>
<li>  A <code>const</code> variable can (only) appear in context where a literal can appear.</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-c1">Size</span> = <span class="pl-c1">7</span>; <span class="pl-c">//disallowed</span></pre></div>

<ul>
<li>  <strong>Good practice is to name literals so all usages can be changed via its initialization value.</strong>
</li>
</ul>

<h3>
<a id="user-content-255-c-string" class="anchor" href="#255-c-string" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.5.5 C++ String</h3>

<ul>
<li>  <code>string (#include &lt;string&gt;)</code> is a sequence of characters with powerful operations performing actions on groups of characters.</li>
<li>  C provided strings by an array of <code>char</code>, string literals, and library facilities.</li>
</ul>

<div class="highlight highlight-source-c"><pre><span class="pl-k">char</span> s[<span class="pl-c1">10</span>]; <span class="pl-c">// string of at most 10 characters</span></pre></div>

<ul>
<li>  Because C-string variable is fixed-sized array:

<ul>
<li>  management of variable-sized strings is the programmer's responsibility</li>
<li>  requiring complex storage management</li>
</ul>
</li>
<li>  C++ solves these problems by providing a "string" type:

<ul>
<li>  maintaining string length versus sentinel character <code>'\0'</code>
</li>
<li>  managing storage for variable-size string</li>
</ul>
</li>
</ul>

<table>
<thead>
<tr>
<th>C <code>char []</code>
</th>
<th>C++ string</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>strcpy</code> <code>strncpy</code>
</td>
<td><code>=</code></td>
</tr>
<tr>
<td>
<code>strcat</code> <code>strncat</code>
</td>
<td><code>+</code></td>
</tr>
<tr>
<td>
<code>strcmp</code> <code>strncmp</code>
</td>
<td><code>== != &lt; &lt;= &gt; &gt;=</code></td>
</tr>
<tr>
<td><code>strlen</code></td>
<td><code>length</code></td>
</tr>
<tr>
<td><code>[]</code></td>
<td><code>[]</code></td>
</tr>
<tr>
<td></td>
<td><code>substr</code></td>
</tr>
<tr>
<td></td>
<td><code>replace</code></td>
</tr>
<tr>
<td><code>strstr</code></td>
<td>
<code>find</code> <code>rfind</code>
</td>
</tr>
<tr>
<td><code>strcspn</code></td>
<td>
<code>find_first_of</code> <code>find_last_of</code>
</td>
</tr>
<tr>
<td><code>strspn</code></td>
<td>
<code>find_first_not_of</code> <code>find_last_not_of</code>
</td>
</tr>
<tr>
<td></td>
<td><code>c_str</code></td>
</tr>
</tbody>
</table>

<ul>
<li>  <code>find</code> routines return value <code>string::npos</code> of type <code>string::size_type</code> if unsuccessful search</li>
<li>  <code>c_str</code> converts a string to a <code>char *</code> pointer (<code>'\0'</code> terminated)</li>
<li>  <strong>Note different call syntax <code>c.substr(2,3)</code> versus <code>substr(c,2,3)</code></strong>
</li>
<li>  contrast C and C++ style strings (note the management of string storage)</li>
</ul>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>string.h<span class="pl-pds">&gt;</span></span> <span class="pl-c">// C string routines</span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>string<span class="pl-pds">&gt;</span></span> <span class="pl-c">// C++ string routines</span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-k">int</span> <span class="pl-en">main</span> () {
    <span class="pl-c">// C++ string</span>
    <span class="pl-k">const</span> string X = <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, Y = <span class="pl-s"><span class="pl-pds">"</span>def<span class="pl-pds">"</span></span>, Z = <span class="pl-s"><span class="pl-pds">"</span>ghi<span class="pl-pds">"</span></span>;
    string S = X + Y + Z;
    <span class="pl-c">// C string</span>
    <span class="pl-k">const</span> <span class="pl-k">char</span> *x = <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, *y = <span class="pl-s"><span class="pl-pds">"</span>def<span class="pl-pds">"</span></span>, *z = <span class="pl-s"><span class="pl-pds">"</span>ghi<span class="pl-pds">"</span></span>;
    <span class="pl-k">char</span> s[<span class="pl-c1">strlen</span>(x)+<span class="pl-c1">strlen</span>(y)+<span class="pl-c1">strlen</span>(z)+<span class="pl-c1">1</span>];
    <span class="pl-c1">strcpy</span>(s, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>); <span class="pl-c">// init to null string</span>
    <span class="pl-c1">strcat</span>(<span class="pl-c1">strcat</span>(<span class="pl-c1">strcat</span>(s,x),y),z);
}</pre></div>

<ul>
<li>  <strong>Good practice is NOT to iterate through the characters of a string variable!</strong>
</li>
</ul>

<h2>
<a id="user-content-26-inputoutput" class="anchor" href="#26-inputoutput" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.6 Input/Output</h2>

<ul>
<li>  Input/Output (I/O) is divided into two kinds:

<ul>
<li>  <strong>Formatted I/O</strong> transfers data with implicit conversion of internal values to/from human-readable form</li>
<li>  <strong>Unformatted I/O</strong> transfers data without conversion, e.g., internal integer and real floating values</li>
</ul>
</li>
</ul>

<h3>
<a id="user-content-261-formatted-io" class="anchor" href="#261-formatted-io" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.6.1 Formatted I/O</h3>

<table>
<thead>
<tr>
<th>C</th>
<th>C++</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#inlcude &lt;stdio.h&gt;</code></td>
<td><code>#include &lt;iostream&gt;</code></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>FILE</code></td>
<td>
<code>ifstream</code> <code>ofstream</code>
</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>in = fopen("f", "r")</code></td>
<td><code>ifstream in("f")</code></td>
</tr>
<tr>
<td><code>out = fopen("f", "w")</code></td>
<td><code>ofstream out("f")</code></td>
</tr>
<tr>
<td><code>close(in)</code></td>
<td>scope ends, <code>in.close()</code>
</td>
</tr>
<tr>
<td><code>close(out)</code></td>
<td>scope ends, <code>out.close()</code>
</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>fscanf(in, "%d", &amp;i)</code></td>
<td><code>in&gt;&gt;T</code></td>
</tr>
<tr>
<td><code>fscanf(in, "%f", &amp;f)</code></td>
<td></td>
</tr>
<tr>
<td><code>fscanf(in, "%c", &amp;c)</code></td>
<td></td>
</tr>
<tr>
<td><code>fscanf(in, "%s", &amp;s)</code></td>
<td></td>
</tr>
<tr>
<td><code>feof(in)</code></td>
<td><code>in.fail()</code></td>
</tr>
<tr>
<td>
<code>fscanf</code> return value</td>
<td><code>in.fail()</code></td>
</tr>
<tr>
<td></td>
<td><code>in.clear()</code></td>
</tr>
<tr>
<td><code>fscanf(in, "%*[regexp]")</code></td>
<td><code>in.ignore(n,c)</code></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>fprintf(out),"%d",i)</code></td>
<td><code>out&lt;&lt;T</code></td>
</tr>
<tr>
<td><code>fprintf(out),"%f",f)</code></td>
<td></td>
</tr>
<tr>
<td><code>fprintf(out),"%c",c)</code></td>
<td></td>
</tr>
<tr>
<td><code>fprintf(out),"%s",s)</code></td>
<td></td>
</tr>
</tbody>
</table>

<ul>
<li>  Formatted I/O occurs to/from a <strong>stream file</strong>, and values are conversed based on the type of variables and format codes</li>
<li>  C++ has three implicit stream files: <code>cin</code> <code>cout</code> and <code>cerr</code>, which are implicitly declared and opened</li>
<li>  C has <code>stdin</code>, <code>stdout</code> and <code>stderr</code>, which are implicitly declared and opened</li>
<li>  <code>#inlcude &lt;iostream&gt;</code> imports all necessary declarations to access <code>cin</code> <code>cout</code> and <code>cerr</code>
</li>
<li>  <code>cin</code> reads input from the keyboard</li>
<li>  <code>cout/cerr</code> write to the terminal screen</li>
<li>  <strong>Error and debugging messages should always be written to <code>cerr</code></strong>

<ul>
<li>  normally not redirected by the shell</li>
<li>  unbuffered so output appears immediately</li>
</ul>
</li>
<li>  stream files other than 3 implicit ones require declaring each file object</li>
</ul>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>fstream<span class="pl-pds">&gt;</span></span> <span class="pl-c">// required for stream-file declarations</span>
ifstream <span class="pl-en">infile</span> (<span class="pl-s"><span class="pl-pds">"</span>myinfile<span class="pl-pds">"</span></span>); <span class="pl-c">// input file</span>
ofstream <span class="pl-en">outfile</span> (<span class="pl-s"><span class="pl-pds">"</span>myoutfile<span class="pl-pds">"</span></span>) <span class="pl-c">// output file</span></pre></div>

<ul>
<li>  file <code>types</code> <code>ifstream</code> <code>ofstream</code> indicate whether the file can be read or written</li>
<li>  file name type <code>"myinfile" "myoutfile"</code> is <code>char *</code>
</li>
<li>  declaration opens an operating-system file making it accessible through the variable name:

<ul>
<li>  <code>infile</code> reads from file <code>myinfile</code>
</li>
<li>  <code>outfile</code> writes to file <code>myoutfile</code>
where both files are located in the directory where the program is run</li>
</ul>
</li>
<li>  check for successful opening of a file using the stream member <code>fail</code> e.g. <code>infile.fail()</code>, which returns <code>true</code> if the open failed and <code>false</code> otherwise</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">if</span> (infile.fail()) <span class="pl-c">// open failed, print message and exit</span>
<span class="pl-k">if</span> (outfile.fail()) <span class="pl-c">// open failed, print message and exit</span></pre></div>

<ul>
<li>  C++ I/O library overloads the bit-shift operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> to perform I/O</li>
<li>  C I/O library uses <code>fscanf(outfile,...)</code> and <code>fprintf(infile,...)</code>, which have short forms <code>scanf(...)</code> and <code>printf(...)</code> for <code>stdin</code> and <code>stdout</code>
</li>
<li>  Both I/O libraries can cascade multiple I/O operations, i.e., input or output multiple values in a single expression.</li>
</ul>

<h4>
<a id="user-content-2611-formats" class="anchor" href="#2611-formats" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.6.1.1 Formats</h4>

<ul>
<li>  Format of input/output values is controlled via <strong>manipulators</strong> defined in <code>#include &lt;iomanip&gt;</code>
</li>
</ul>

<table>
<thead>
<tr>
<th>manipulator</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>oct (%o)</code></td>
<td>integral values in octal</td>
</tr>
<tr>
<td><code>dec (%d)</code></td>
<td>integral values in decimal</td>
</tr>
<tr>
<td><code>hex (%x)</code></td>
<td>integral values in hexadecimal</td>
</tr>
<tr>
<td>
<code>left</code> <code>right</code>
</td>
<td>values with padding after / before values</td>
</tr>
<tr>
<td>
<code>boolalpha</code> <code>noboolalpha</code>
</td>
<td>bool values as false/true instead of 0/1</td>
</tr>
<tr>
<td>
<code>showbase</code> <code>noshowbase</code>
</td>
<td>values with / without prefix 0 for octal &amp; 0x for hex</td>
</tr>
<tr>
<td>
<code>showpoint</code> <code>noshowpoint</code>
</td>
<td>print decimal point if no fraction</td>
</tr>
<tr>
<td>
<code>fixed</code> <code>scientific</code>
</td>
<td>float-point values without / with exponent</td>
</tr>
<tr>
<td><code>setfill('ch')</code></td>
<td>padding character before/after value (default blank)</td>
</tr>
<tr>
<td><code>setw(W) (%Wd)</code></td>
<td>NEXT VALUE ONLY in minimum of W columns</td>
</tr>
<tr>
<td><code>setprecision(P) %(Pf)</code></td>
<td>faction of float-point values in maximum of P columns</td>
</tr>
<tr>
<td><code>endl (\n)</code></td>
<td>flush output buffer and start new line</td>
</tr>
<tr>
<td><code>skipws / noskipws</code></td>
<td>skip whitespace characters</td>
</tr>
</tbody>
</table>

<ul>
<li>  <strong>Manipulators are not variables for input/output</strong>, but control I/O formatting for all literals/variables after it, continuing to the next I/O expression for a specific stream file.</li>
<li>  <strong>Except manipulator <code>setw</code> which only applies to the next value in the I/O expression</strong>
</li>
<li>  <code>endl</code> is not the same as <code>'\n'</code>, as <code>'\n'</code> does not flush buffered data</li>
<li>  for input, <code>skipws/noskipws</code> toggle between ignoring whitespace between input tokens and reading whitespace</li>
</ul>

<h4>
<a id="user-content-2612-output" class="anchor" href="#2612-output" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.6.1.2 Output</h4>

<ul>
<li>  Java output style converts values to string, concatenates strings, and prints final long string:</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(i <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> <span class="pl-k">+</span> j); <span class="pl-c">// build a string and print it</span></pre></div>

<ul>
<li>  C/C++ output style has a list of formats and values, and output operation generate strings:</li>
</ul>

<div class="highlight highlight-source-c++"><pre>cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; j &lt;&lt; endl; <span class="pl-c">// print each string as formed</span></pre></div>

<ul>
<li>  No implicit conversion from the basic types to string in C++</li>
<li>  <strong>While it is possible to use the Java string-concatenation style in C++, it is incorrect style</strong>
</li>
</ul>

<h4>
<a id="user-content-2613-input" class="anchor" href="#2613-input" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.6.1.3 Input</h4>

<ul>
<li>  C++ formatted input has implicit character conversion for all basic types and is extensible to user-defined types</li>
<li>  Numeric input values are C/C++ undesignated literals: <code>3, 3.5e-1</code> separated by whitespace</li>
<li>  Character/string input values are characters separated by whitespace</li>
<li>  Type of operand indicates the kind of value expected in the stream</li>
<li>  Input starts reading where the last input left off, and scans lines to obtain necessary number of values</li>
<li>  C/C++ must attempt and read before end-of-file is set and can be tested</li>
<li>  End of file is the detection the physical end of a file; there is no end-of-file character</li>
<li>  In shell typing <code>ctrl-d</code> causes shell to close current input file marking its physical end</li>
<li>  In C++, eof can be explicitly detected in two ways:

<ul>
<li>  stream member <code>eof</code> return true if the eof is reached and false otherwise</li>
<li>  stream member <code>fail</code> returns true for invalid or no value if eof is reached and false otherwise</li>
</ul>
</li>
<li>  Safer to check <code>fail</code> and then check <code>eof</code>
</li>
<li>  If <code>"abc"</code> is entered (invalid integer value), <code>fail</code> becomes true but <code>eof</code> is false</li>
<li>  Generates infinite loop as invalid data is not skipped for subsequent reads</li>
<li>  Stream is implicitly converted to bool in an integer <code>if !fail()</code> true, otherwise false</li>
<li>  After unsuccessful read call <code>clear()</code>  to reset <code>fail()</code> before next read</li>
<li>  <code>ignore</code> skips $n$ characters</li>
<li>  <code>getline(stream, string, char)</code> reads strings with white spaces allowing different delimiting characters (no buffer overflow)</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-en">getline</span>(cin,c,<span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>); <span class="pl-c">// read characters until ' ' =&gt; cin &gt;&gt; c</span>
<span class="pl-en">getline</span>(cin,c,<span class="pl-s"><span class="pl-pds">'</span>@<span class="pl-pds">'</span></span>); <span class="pl-c">// read characters until '@'</span>
<span class="pl-en">getline</span>(cin,c,<span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>); <span class="pl-c">// read character until newline (default)</span></pre></div>

<ul>
<li>  Read in file-names, which may contain spaces, and process each file:</li>
</ul>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>fstream<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    ifstream <span class="pl-smi">fileName</span>(<span class="pl-s"><span class="pl-pds">"</span>filenames<span class="pl-pds">"</span></span>);
    string fileName;
    <span class="pl-k">for</span> ( ;; ) {
        <span class="pl-c1">getline</span>(fileNames, fileName);
        <span class="pl-k">if</span> (fileNames.<span class="pl-c1">fail</span>()) <span class="pl-k">break</span>;
        ifstream <span class="pl-smi">file</span>(fileName);
        <span class="pl-c">// read and process file</span>
    }
}</pre></div>

<ul>
<li>  In C, routine <code>feof</code> returns true when eof is reached <code>fscanf</code> returns EOF</li>
<li>  Parameters in C are always passed by value, so arguments to <code>fscanf</code> must be preceded with &amp; (except arrays) so they can be changed</li>
<li>  <code>stringstream</code> allows I/O from a string</li>
<li>  Tokenized whitespace separated word</li>
</ul>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>sstream<span class="pl-pds">&gt;</span></span>
string tok, line = <span class="pl-s"><span class="pl-pds">"</span>  the <span class="pl-cce">\"</span>quick<span class="pl-cce">\"</span> brown<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
stringstream ss;
ss.str(line);
<span class="pl-k">while</span> (ss &gt;&gt; tok) {
    cout &lt;&lt; tok &lt;&lt; endl;
}
ss.clear();
ss.str(<span class="pl-s"><span class="pl-pds">"</span>17<span class="pl-pds">"</span></span>);
<span class="pl-k">int</span> i;
ss &gt;&gt; i;
cout &lt;&lt; i &lt;&lt; endl;</pre></div>

<h2>
<a id="user-content-27-expression" class="anchor" href="#27-expression" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.7 Expression</h2>

<table>
<thead>
<tr>
<th></th>
<th>C/C++</th>
<th>Priority</th>
</tr>
</thead>
<tbody>
<tr>
<td>postfix</td>
<td>
<code>::</code> <code>.</code> <code>-&gt;</code> <code>[]</code> <code>call</code> <code>cast</code>
</td>
<td>high</td>
</tr>
<tr>
<td>prefix (unary)</td>
<td>
<code>+</code> <code>-</code> <code>!</code> <code>~</code> <code>&amp;</code> <code>*</code> <code>cast</code> <code>new</code> <code>delete</code> <code>sizeof</code>
</td>
<td></td>
</tr>
<tr>
<td>binary</td>
<td>
<code>*</code> <code>/</code> <code>%</code>
</td>
<td></td>
</tr>
<tr>
<td></td>
<td>
<code>+</code> <code>-</code>
</td>
<td></td>
</tr>
<tr>
<td>bit shift</td>
<td>
<code>&lt;&lt;</code> <code>&gt;&gt;</code>
</td>
<td></td>
</tr>
<tr>
<td>relational</td>
<td>
<code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code>
</td>
<td></td>
</tr>
<tr>
<td>equality</td>
<td>
<code>==</code> <code>!=</code>
</td>
<td></td>
</tr>
<tr>
<td>bitwise</td>
<td><code>&amp;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>^</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>|</code></td>
<td></td>
</tr>
<tr>
<td>logical</td>
<td><code>&amp;&amp;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>||</code></td>
<td></td>
</tr>
<tr>
<td>conditional</td>
<td><code>? :</code></td>
<td></td>
</tr>
<tr>
<td>assignment</td>
<td>
<code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code>
</td>
<td></td>
</tr>
<tr>
<td>comma</td>
<td><code>,</code></td>
<td>low</td>
</tr>
</tbody>
</table>

<ul>
<li>  Subexpressions and argument evaluation is unspecified</li>
</ul>

<div class="highlight highlight-source-c++"><pre>(i+j)*(k+j);       <span class="pl-c">// either + done first</span>
(i=j)+(j=i);       <span class="pl-c">// either = done first</span>
<span class="pl-en">g</span>(i) + f(k) +h(j); <span class="pl-c">//g f or h called in any order</span>
<span class="pl-en">f</span>(p++, p++, p++);  <span class="pl-c">// arguments evaluated in any order</span></pre></div>

<ul>
<li><strong>Beware of overflow</strong></li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">unsigned</span> <span class="pl-k">int</span> a = <span class="pl-c1">4294967295</span>, b = <span class="pl-c1">4294967295</span>, c = <span class="pl-c1">4294967295</span>;
(a+b)/c;    <span class="pl-c">// =&gt; 0 as a+b overflows leaving zero</span>
(a/c)+(b/c) <span class="pl-c">// =&gt; 2</span></pre></div>

<p><strong>Perform divides before multiplies (if possible) to keep numbers small</strong></p>

<ul>
<li>  C++ relational/equality return <code>false / true</code>; C return <code>0/1</code>
</li>
<li>  General assignment operators only evaluate left-hand side once:</li>
</ul>

<div class="highlight highlight-source-c++"><pre>v[f(<span class="pl-c1">3</span>)] += <span class="pl-c1">1</span>;          <span class="pl-c">// only calls f once</span>
v[f(<span class="pl-c1">3</span>)] = v[f(<span class="pl-c1">3</span>)] + <span class="pl-c1">1</span>; <span class="pl-c">// calls f twice</span></pre></div>

<ul>
<li>  Bit-shift operators, <code>&lt;&lt;</code> (left), and <code>&gt;&gt;</code> (right) shift bits in integral variables left and right.

<ul>
<li>  left shift is multiplying by 2, modulus variable's size</li>
<li>  right shift is dividing by 2 if unsigned or positive</li>
<li>  undefined if right operand is negative or $\geq$ to length of left operand.</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">int</span> x, y, z;
x = y = z = <span class="pl-c1">1</span>;
cout &lt;&lt; (x &lt;&lt; <span class="pl-c1">1</span>) &lt;&lt; ’ ’ &lt;&lt; (y &lt;&lt; <span class="pl-c1">2</span>) &lt;&lt; ’ ’ &lt;&lt; (z &lt;&lt; <span class="pl-c1">3</span>) &lt;&lt; endl;
x = y = z = <span class="pl-c1">16</span>;
cout &lt;&lt; (x &gt;&gt; <span class="pl-c1">1</span>) &lt;&lt; ’ ’ &lt;&lt; (y &gt;&gt; <span class="pl-c1">2</span>) &lt;&lt; ’ ’ &lt;&lt; (z &gt;&gt; <span class="pl-c1">3</span>) &lt;&lt; endl;
<span class="pl-c1">2</span> <span class="pl-c1">4</span> <span class="pl-c1">8</span>
<span class="pl-c1">8</span> <span class="pl-c1">4</span> <span class="pl-c1">2</span></pre></div>

<h3>
<a id="user-content-271-conversion" class="anchor" href="#271-conversion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.7.1 Conversion</h3>

<ul>
<li>  <strong>Conversion</strong> transforms a value of another type by changing the value of the new type's representation.</li>
<li>  Conversions occur implicitly by compiler or explicitly by programmer using <strong>cast</strong> operator or C++ <strong>static_cast</strong> operator.</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">int</span> i; <span class="pl-k">double</span> d;
d = i; <span class="pl-c">// implicit (compiler)</span>
d = (<span class="pl-k">double</span>) i; <span class="pl-c">// explicit with cast (programmer)</span>
d = <span class="pl-k">static</span> cast&lt;<span class="pl-k">double</span>&gt;( i ); <span class="pl-c">// C++</span></pre></div>

<ul>
<li>  Two kinds of conversions:

<ul>
<li>  <strong>widening/promotion</strong> conversion, no information is lost
bool -&gt; char -&gt; shoft int -&gt; long int -&gt; double</li>
<li>  <strong>narrowing</strong> conversion, information can be lost:
double -&gt; char -&gt; short int -&gt; long int -&gt; double</li>
</ul>
</li>
<li>  C/C++ have implicit widening and narrowing conversions</li>
<li>  <strong>Beware of implicit narrowing conversions</strong>
</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">int</span> i; <span class="pl-k">double</span> d;
i = d = <span class="pl-c1">3.5</span>; <span class="pl-c">// d -&gt; 3.5</span>
d = i = <span class="pl-c1">3.5</span>; <span class="pl-c">// d -&gt; 3.0 truncation</span></pre></div>

<ul>
<li>  Good practice is to perform narrowing conversions explicitly with cast as documentation.</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">int</span> i; <span class="pl-k">double</span> d1 = <span class="pl-c1">7.2</span>, d2 = <span class="pl-c1">3.5</span>;
i = (<span class="pl-k">int</span>) d1; <span class="pl-c">// explicit narrowing conversion</span>
i = (<span class="pl-k">int</span>) d1 / (<span class="pl-k">int</span>) d2; <span class="pl-c">// explicit narrowing conversions for integer division</span>
i = <span class="pl-k">static</span> cast&lt;<span class="pl-k">int</span>&gt;(d1 / d2); <span class="pl-c">// alternative technique after integer division</span></pre></div>

<ul>
<li>  C++ supports casting among user defined types</li>
</ul>

<h3>
<a id="user-content-272-coercion" class="anchor" href="#272-coercion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.7.2 Coercion</h3>

<ul>
<li>  <strong>Coercion</strong> reinterprets a value to another type but the result is may not be meaningful in the new type's representation.</li>
<li>  Some narrowing conversions are considered coercions.

<ul>
<li>  e.g. when a value is truncated or converting non-zero to <code>true</code>, the result is nonsense in the new type's representation.</li>
</ul>
</li>
<li>  Also, having type <code>char</code> represent ASCII characters and integral (byte) values allows:</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">char</span> ch = <span class="pl-s"><span class="pl-pds">'</span>z<span class="pl-pds">'</span></span> - <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>; <span class="pl-c">// character arithmetic</span></pre></div>

<p>which is often unreasonable as it can generate an invalid character.</p>

<ul>
<li>  But the most common coercion is through pointers:</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">int</span> i, *ip = &amp;i; <span class="pl-c">// ip is a pointer to an integer</span>
<span class="pl-k">double</span> d, *dp = &amp;d; <span class="pl-c">// dp is a pointer to a double</span>
dp = (<span class="pl-k">double</span> *) ip; <span class="pl-c">// lie, say dp points at double but really an integer</span>
dp = reinterpret cast&lt;<span class="pl-k">double</span> *&gt;( ip );</pre></div>

<p>using explicit cast, programmer has lied to compiler about type of <code>ip</code></p>

<ul>
<li>  Signed/unsigned coercion</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">unsigned</span> <span class="pl-k">int</span> size;
cin &gt;&gt; size; <span class="pl-c">// negatives become positives</span>
<span class="pl-k">if</span> ( size &lt; <span class="pl-c1">0</span> ) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>invalid range<span class="pl-pds">"</span></span> &lt;&lt; endl;
<span class="pl-k">int</span> arr[size];</pre></div>

<ul>
<li>  <code>size</code> is unsigned because an array cannot have negative size.</li>
<li>  <code>cin</code> does not check for negative values for <code>unsigned</code> =&gt; 2 reads as 4294967294</li>
<li>  Use safe coercion for checking range of size</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">if</span> ((<span class="pl-k">int</span>)size &lt; <span class="pl-c1">0</span>) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>invalid range<span class="pl-pds">"</span></span> &lt;&lt; endl;</pre></div>

<ul>
<li>  Must be consistent with types</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">for</span> ( <span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; size; i += <span class="pl-c1">1</span> ) { }
. . .
test.cc:<span class="pl-c1">12</span>:<span class="pl-c1">22</span>: warning: comparison between <span class="pl-k">signed</span> <span class="pl-k">and</span> <span class="pl-k">unsigned</span> integer expressions</pre></div>

<ul>
<li>  <strong>Good practice is to limit narrowing conversions and NEVER lie about a variable's type</strong>
</li>
</ul>

<h2>
<a id="user-content-28-unformatted-io" class="anchor" href="#28-unformatted-io" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.8 Unformatted I/O</h2>

<ul>
<li>  Expensive to convert from internal (computer) to external (human) forms (bits &lt;=&gt; characters)</li>
<li>  When data does not have to be seen by a human, use efficient unformatted I/O so no conversions.</li>
<li>  Uses same mechanisms as formatted I/O to connect variable to file (open / close)</li>
<li>  <code>read</code> and <code>write</code> routines directly transfer bytes from/to a file, where each takes a pointer to the data and number of bytes of data.</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-en">read</span>( <span class="pl-k">char</span> *data, streamsize num );
<span class="pl-en">write</span>( <span class="pl-k">char</span> *data, streamsize num );</pre></div>

<ul>
<li>  Read/write of types other than characters requires a coercion cast or C++ <code>reinterpret_cast</code>
</li>
</ul>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>fstream<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    <span class="pl-k">const</span> <span class="pl-k">unsigned</span> <span class="pl-k">int</span> size = <span class="pl-c1">10</span>;
    <span class="pl-k">int</span> arr[size];
    { <span class="pl-c">// read array</span>
        ifstream <span class="pl-smi">infile</span>( <span class="pl-s"><span class="pl-pds">"</span>myfile<span class="pl-pds">"</span></span> ); <span class="pl-c">// open input file “myfile”</span>
        infile.<span class="pl-c1">read</span>( reinterpret cast&lt;<span class="pl-k">char</span> *&gt;(&amp;arr), size * <span class="pl-k">sizeof</span>( arr[<span class="pl-c1">0</span>] ) ); <span class="pl-c">// coercion</span>
    } <span class="pl-c">// close file</span>
    . . . <span class="pl-c">// modify array</span>
    { <span class="pl-c">// print array</span>
        ofstream <span class="pl-smi">outfile</span>( <span class="pl-s"><span class="pl-pds">"</span>myfile<span class="pl-pds">"</span></span> ); <span class="pl-c">// open output file “myfile”</span>
        outfile.<span class="pl-c1">write</span>( (<span class="pl-k">char</span> *)&amp;arr, size * <span class="pl-k">sizeof</span>( arr[<span class="pl-c1">0</span>] ) ); <span class="pl-c">// coercion</span>
    } <span class="pl-c">// close file</span>
}</pre></div>

<ul>
<li>  Need special command to view unformatted file as printable characters</li>
<li>  E.g., view internal values as bytes sequence for 32-bit <code>int</code> values</li>
</ul>

<div class="highlight highlight-source-shell"><pre>$ od -t u1 myfile
0000000 0 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0
0000020 4 0 0 0 5 0 0 0 6 0 0 0 7 0 0 0
0000040 8 0 0 0 9 0 0 0</pre></div>

<ul>
<li>  Coercion is unnecessary if buffer type was <code>void *</code>
</li>
</ul>

<h2>
<a id="user-content-29-math-operations" class="anchor" href="#29-math-operations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.9 Math Operations</h2>

<ul>
<li>  <code>#include &lt;cmath&gt;</code> provides overloaded real-float mathematical-routine for types <code>float</code>, <code>double</code> and <code>long double</code>.</li>
</ul>

<table>
<thead>
<tr>
<th>operation</th>
<th>routine</th>
<th></th>
<th>operation</th>
<th>routine</th>
</tr>
</thead>
<tbody>
<tr>
<td>$|x|$</td>
<td><code>abs(x)</code></td>
<td></td>
<td>$x \mod y$</td>
<td><code>fmod(x,y)</code></td>
</tr>
<tr>
<td>$\arccos x$</td>
<td><code>acos(x)</code></td>
<td></td>
<td>$\ln x$</td>
<td><code>log(x)</code></td>
</tr>
<tr>
<td>$\arcsin x$</td>
<td><code>asin(x)</code></td>
<td></td>
<td>$\log x$</td>
<td><code>log10(x)</code></td>
</tr>
<tr>
<td>$\arctan x$</td>
<td><code>atan(x)</code></td>
<td></td>
<td>$x^y$</td>
<td><code>pow(x,y)</code></td>
</tr>
<tr>
<td>$\lceil{x}\rceil$</td>
<td><code>ceil(x)</code></td>
<td></td>
<td>$\sin x$</td>
<td><code>sin(x)</code></td>
</tr>
<tr>
<td>$\cos x$</td>
<td><code>cos(x)</code></td>
<td></td>
<td>$\sinh x$</td>
<td><code>sinh(x)</code></td>
</tr>
<tr>
<td>$\cosh x$</td>
<td><code>cosh(x)</code></td>
<td></td>
<td>$\sqrt{x}$</td>
<td><code>sqrt(x)</code></td>
</tr>
<tr>
<td>$e^x$</td>
<td><code>exp(x)</code></td>
<td></td>
<td>$\tan x$</td>
<td><code>tan(x)</code></td>
</tr>
<tr>
<td>$\lfloor{x}\rfloor$</td>
<td><code>floor(x)</code></td>
<td></td>
<td>$\tanh(x)$</td>
<td><code>tanh(x)</code></td>
</tr>
</tbody>
</table>

<ul>
<li>  Some systems also provide <code>long double</code> math constants</li>
<li>  <code>pow(x,y)</code> $(x^y)$ is computed using logarithm, $10^{y\log x}$ (versus repeated multiplication), when $y$ is non-integral value =&gt; $y\geq 0$</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-en">pow</span>( -<span class="pl-c1">2.0</span>, <span class="pl-c1">3.0</span> ); −<span class="pl-c1">23</span> = −<span class="pl-c1">2</span>×−<span class="pl-c1">2</span>×−<span class="pl-c1">2</span> = −<span class="pl-c1">8</span>
<span class="pl-en">pow</span>( -<span class="pl-c1">2.0</span>, <span class="pl-c1">3.1</span> ); −<span class="pl-c1">23.1</span> = <span class="pl-c1">103.1</span>×log−<span class="pl-c1">2.0</span> = nan (<span class="pl-k">not</span> a number)</pre></div>

<ul>
<li>  Quadratic roots of $ax^2+bx+c$ are $r=(-b\pm \sqrt{b^2-4ac})/2a$</li>
</ul>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>cmath<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    <span class="pl-k">double</span> a = <span class="pl-c1">3.5</span>, b = <span class="pl-c1">2.1</span>, c = -<span class="pl-c1">1.2</span>;
    <span class="pl-k">double</span> dis = <span class="pl-c1">sqrt</span>( b * b - <span class="pl-c1">4.0</span> * a * c ), dem = <span class="pl-c1">2.0</span> * a;
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>root1: <span class="pl-pds">"</span></span> &lt;&lt; ( -b + dis ) / dem &lt;&lt; endl;
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>root2: <span class="pl-pds">"</span></span> &lt;&lt; ( -b - dis ) / dem &lt;&lt; endl;
}</pre></div>

<h2>
<a id="user-content-210-control-structures" class="anchor" href="#210-control-structures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.10 Control Structures</h2>

<ul>
<li>  block</li>
</ul>

<div class="highlight highlight-source-c++"><pre>{ intermixed decls/stmts }</pre></div>

<ul>
<li>  selection</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">if</span> ( <span class="pl-k">bool</span>-expr1 ) stmt1
<span class="pl-k">else</span> <span class="pl-k">if</span> ( <span class="pl-k">bool</span>-expr2 ) stmt2
. . .
<span class="pl-k">else</span> stmtN

<span class="pl-k">switch</span> ( integral-expr ) {
    <span class="pl-k">case</span> c1: stmts1; <span class="pl-k">break</span>;
    . . .
    <span class="pl-k">case</span> cN: stmtsN; <span class="pl-k">break</span>;
    <span class="pl-k">default</span>: stmts0;
}</pre></div>

<ul>
<li>  looping</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">while</span> ( <span class="pl-k">bool</span>-expr ) stmt

<span class="pl-k">do</span> stmt <span class="pl-k">while</span> ( <span class="pl-k">bool</span>-expr ) ;

<span class="pl-k">for</span> (init-expr ;<span class="pl-k">bool</span>-expr ;incr-expr ) stmt</pre></div>

<ul>
<li>  transfer</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">break</span>
<span class="pl-k">continue</span>
<span class="pl-k">goto</span> label
<span class="pl-k">return</span> [ expr ]
<span class="pl-k">throw</span> [ expr ]</pre></div>

<ul>
<li>  label</li>
</ul>

<div class="highlight highlight-source-c++"><pre>label: stmt</pre></div>

<h3>
<a id="user-content-2101-block" class="anchor" href="#2101-block" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.10.1 Block</h3>

<ul>
<li>  Compound statement serves two purposes

<ul>
<li>  bracket several statements into a single statement</li>
<li>  introduce local declarations</li>
</ul>
</li>
<li>  <strong>Good practice is use a block versus single statement to allow adding statements</strong>
</li>
<li>  Nested block variables are allocated last-in first-out (LIFO) from the <strong>stack</strong> memory area</li>
</ul>

<table>
<thead>
<tr>
<th>code</th>
<th>static</th>
<th>heap</th>
<th>&lt;- free memory -&gt;</th>
<th>stack</th>
</tr>
</thead>
<tbody>
</tbody>
</table>

<ul>
<li>  Nested block declarations reduces declaration clutter at start of block</li>
<li>  Variable names can be reused in different blocks, i.e., possible <strong>shadow</strong> (hiding) prior variables</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">int</span> i = <span class="pl-c1">1</span>; . . . <span class="pl-c">// first i</span>
{ <span class="pl-k">int</span> k = i, i = <span class="pl-c1">2</span>, j = i; . . . <span class="pl-c">// k = first i, second i overrides first</span>
    { <span class="pl-k">int</span> i = <span class="pl-c1">3</span>;. . .}} <span class="pl-c">// third i (overrides second)</span></pre></div>

<h3>
<a id="user-content-2102-selection" class="anchor" href="#2102-selection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.10.2 Selection</h3>

<ul>
<li>  C/C++ selection statements are <code>if</code> and <code>switch</code>
</li>
<li>  For nested <code>if</code> statements, <code>else</code> matches closest <code>if</code>, which results in the <strong>dangling else</strong> problem</li>
<li>  Unnecessary equality for boolean as value is already <code>true</code> or <code>false</code>
</li>
<li>  Redundant <code>if</code> statement</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">if</span> ( a &lt; b ) {
    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
}
<span class="pl-k">else</span> {
    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
}</pre></div>

<ul>
<li>  Conversion causes problems (use <code>-Wall</code>)</li>
<li>  Assign in expressions causes problems because conditional expression is tested for $\neq 0$</li>
<li>  A <code>switch</code> statement selectively executes one of $N$ alternatives based on matching an <strong>integral</strong> value with a series of case clauses</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">switch</span> ( day ) { <span class="pl-c">// integral expression</span>
    <span class="pl-c">// STATEMENTS HERE NOT EXECUTED!!!</span>
    <span class="pl-k">case</span> Mon: <span class="pl-k">case</span> Tue: <span class="pl-k">case</span> Wed: <span class="pl-k">case</span> Thu: <span class="pl-c">// case value list</span>
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>PROGRAM<span class="pl-pds">"</span></span> &lt;&lt; endl;
    <span class="pl-k">break</span>; <span class="pl-c">// exit switch</span>
    <span class="pl-k">case</span> Fri:
    wallet += pay;
    <span class="pl-c">/* FALL THROUGH */</span>
    <span class="pl-k">case</span> Sat:
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>PARTY<span class="pl-pds">"</span></span> &lt;&lt; endl;
    wallet -= party;
    <span class="pl-k">break</span>; <span class="pl-c">// exit switch</span>
    <span class="pl-k">case</span> Sun:
    cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>REST<span class="pl-pds">"</span></span> &lt;&lt; endl;
    <span class="pl-k">break</span>; <span class="pl-c">// exit switch</span>
    <span class="pl-k">default</span>: <span class="pl-c">// optional</span>
    cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>ERROR: bad day<span class="pl-pds">"</span></span> &lt;&lt; endl;
    <span class="pl-c1">exit</span>( EXIT FAILURE ); <span class="pl-c">// TERMINATE PROGRAM</span>
}</pre></div>

<ul>
<li>  Only one label for each <code>case</code> clause but a list of <code>case</code> clauses is allowed.</li>
<li>  Once case label matches, the clauses statements are executed, and control continues to the <code>next</code> statement. (comment each fall through)</li>
<li>  If no case clause is matched and there is a <code>default</code> clause, its statements are executed, and control continues to the next statement.</li>
<li>  Unless there is a <code>break</code> statement to prematurely exit the <code>switch</code> statement.</li>
<li>  <strong>It is a common error to forget the <code>break</code> in <code>case</code> clause</strong>
</li>
<li>  Otherwise, the <code>switch</code> statement does nothing.</li>
<li>  <code>case</code> label does not define a block</li>
</ul>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">switch</span> (i) {
    <span class="pl-k">case</span> <span class="pl-c1">3</span>: { <span class="pl-c">// start new block</span>
        <span class="pl-k">int</span> j = i; <span class="pl-c">// can now declare new variables</span>
    }
}</pre></div>

<h3>
<a id="user-content-2103-multi-exit-loop-review" class="anchor" href="#2103-multi-exit-loop-review" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.10.3 Multi-Exit Loop (Review)</h3>
</article></body></html>